import bpy
import bmesh
import mathutils
import re
import os
import shutil
addon_path = os.path.dirname(os.path.abspath(__file__))
from .PyVMF import *

bl_info = {
    "name": "Source Engine Collision Tools",
    "description": "Quickly generate and optimize collision models for use in Source Engine",
    "author": "Theanine3D",
    "version": (2, 3, 0),
    "blender": (3, 0, 0),
    "category": "Mesh",
    "location": "Properties -> Object Properties",
    "support": "COMMUNITY"
}

# PROPERTY DEFINITIONS


class SrcEngCollProperties(bpy.types.PropertyGroup):
    Dissolve: bpy.props.BoolProperty(
        name="Dissolve",
        description="If enabled, the resulting collision mesh is much more optimized, but also potentially less accurate. If you prefer accuracy over optimization, disable this",
        default=True)
    Post_Merge: bpy.props.BoolProperty(
        name="Post-Merge",
        description="Can dramatically reduce the hull count for smaller or individual props. Leave this disabled if you're generating collision for entire rooms, levels, or any objects with interior cavities",
        default=False)
    Decimate_Ratio: bpy.props.FloatProperty(
        name="Decimate Ratio",
        subtype="FACTOR",
        description="At 1.0, decimation is disabled. Lower value = stronger decimation, resulting in less accurate but more performant collision mesh. Note: Decimation reduces effectiveness of Merge Adjacent Similars",
        max=1.0,
        min=0.0,
        default=1)
    Fracture_Target: bpy.props.IntProperty(
        name="Fracture Target",
        subtype="UNSIGNED",
        description="This setting is used to limit how many hulls are generated by the Generate Fractured Collision operator",
        soft_max=32,
        min=2,
        default=4)
    Fracture_Gap: bpy.props.FloatProperty(
        name="Gap Width",
        subtype="FACTOR",
        description="How large or small the gap between hulls should be. Used only by the Fracture and Bisection generation methods",
        soft_max=1,
        min=0,
        default=0.02)
    Voxel_Resolution: bpy.props.FloatProperty(
        name="Voxel Resolution",
        subtype="FACTOR",
        description="Used by the Generate Fractured Collision operator",
        soft_max=10,
        min=0.0001,
        default=0.05)
    Extrusion_Modifier: bpy.props.FloatProperty(
        name="Extrude Factor",
        description="The setting affects the extrusion of each hull. Default will work in most cases",
        min=0.001,
        soft_max=200.0,
        default=40.0)
    Merge_Distance: bpy.props.FloatProperty(
        name="Merge Distance",
        description="A value higher than zero will cause close-together vertices to merge, resulting in a more performant (but potentially less accurate) collision mesh",
        min=0.0001,
        soft_max=1,
        default=0.0001)
    Similar_Factor: bpy.props.FloatProperty(
        name="Similar Factor",
        subtype="FACTOR",
        description="Percentage of similarity between hulls that is required in order for them to be merged together. At the default setting, hulls must be 90 percent similar in order to be merged",
        min=.5,
        max=1.0,
        default=.9)
    Thin_Threshold: bpy.props.FloatProperty(
        name="Thin Threshold",
        subtype="FACTOR",
        description="The thinness threshold to use when removing thin hulls. If set to default, the operator will only remove faces with an area that is lower than 10 percent of the average area of all faces",
        min=0.0001,
        max=.5,
        default=.01)
    QC_Folder: bpy.props.StringProperty(
        name="QC Folder",
        subtype="DIR_PATH",
        description="Full path of the folder in which to save the generated QCs",
        default="/export/phys/",
        maxlen=1024)
    QC_Src_Models_Dir: bpy.props.StringProperty(
        name="Models Path",
        description="Path of the folder where your compiled models are stored in the Source Engine game directory. This is the $modelname path from your QC files, but without the model name). Must end with a trailing slash '/'",
        default="mymodels/",
        maxlen=1024)
    QC_Src_Mats_Dir: bpy.props.StringProperty(
        name="Materials Path",
        description="Path of the folder where your VMT and VTF files are stored in the Source Engine game directory. This is the $cdmaterials path from your QC files.  Must end with a trailing slash '/'",
        default="models/mymodels/",
        maxlen=1024)
    QC_SurfaceProp: bpy.props.StringProperty(
        name="Surface Property",
        description="The $surfaceprop setting to assign in the generated QC files. Can be left to default if you don't care about the type of footstep sounds that play when players walk on this collision",
        default="default",
        maxlen=40)
    VMF_File: bpy.props.StringProperty(
        name="VMF File",
        subtype="FILE_PATH",
        description="Path of the VMF map file, created in Hammer or some other mapping tool' ",
        default="",
        maxlen=1024)
    VMF_Remove: bpy.props.BoolProperty(
        name="Remove",
        description="If enabled, partitioned (ie. _part_) collision models will be REMOVED from the VMF along with their corresponding entity (ie. prop_static). Can't be undone. Keep a backup VMF just in case",
        default=False)
    VMF_Export_Dir: bpy.props.StringProperty(
        name="Export to",
        subtype='DIR_PATH',
        description="Folder where exported hulls will be saved as Hammer brush .VMF files",
        default=""
        )
    VMF_Texture: bpy.props.EnumProperty(
        items= [
                ("tools/toolsnodraw", "NODRAW", "Solid / Not rendered"),
                ("tools/toolsinvisible", "INVISIBLE", "Solid / Not rendered"),
                ("tools/toolstrigger", "TRIGGER", "Not solid / Trigger"),
                ("tools/toolsblack", "BLACK", "Solid / Rendered / Not affected by light"),
                ("tools/toolswhite", "WHITE", "Solid / Rendered / Not affected by light"),
                ],
        name="Brush Texture",
        description="The texture to apply to brushes exported as VMF",
        default="tools/toolsnodraw"
    )
    Bisect_Gap: bpy.props.FloatProperty(
        name="Gap Width",
        subtype="FACTOR",
        description="How big the gap should be between bisected sections",
        min=0.001,
        max=.3,
        default=.02)
    Bisections: bpy.props.IntProperty(
        name="Bisections",
        subtype="UNSIGNED",
        description="How many times should the model be bisected along the middle by the 'Generate by Bisection' tool.",
        soft_max=32,
        min=2,
        default=4)
    Bisect_Mode: bpy.props.EnumProperty(
        items= [
                ("xy", "Sides", "Cuts along the X/Y axes, resulting in horizontally flat hulls"),
                ("z", "Top/Bottom", "Cuts along the Z axis, resulting in vertical hulls"),
                ],
        name="Mode",
        description="The method used when bisecting the model to generate the hulls",
        default="xy"
    )
    Split_Increment: bpy.props.IntProperty(
        name="Split Increment",
        subtype="UNSIGNED",
        description="Some versions of Source Engine have a higher or lower limit than the default of 32 hulls per collision mesh. If you're not sure, just use the default setting",
        soft_max=40,
        min=2,
        default=32)
    
# FUNCTION DEFINITIONS


def display_msg_box(message="", title="Info", icon='INFO'):
    ''' Open a pop-up message box to notify the user of something               '''
    ''' Example:                                                                '''
    ''' display_msg_box("This is a message", "This is a custom title", "ERROR") '''

    def draw(self, context):
        lines = message.split("\n")
        for line in lines:
            self.layout.label(text=line)
            print(line)

    bpy.context.window_manager.popup_menu(draw, title=title, icon=icon)


def check_for_selected():
    ''' Checks if any valid mesh objects are selected, and returns a list of the objects if so. Otherwise, returns False'''
    mesh_objs = list()

    for o in bpy.context.selected_objects:
        if o.type == "MESH" and not o.hide_get():
            if len(o.data.polygons) > 0:
                mesh_objs.append(o)
    
    # Check if any objects are selected.
    if len(mesh_objs) >= 1:
        return mesh_objs
    else:
        return False

def get_current_mode():
    obj = bpy.context.active_object
    
    if obj is None:
        return None
    
    return obj.mode

def get_avg_length(obj):
    object = bpy.context.active_object
    edges = object.data.edges
    lengths = list()
    for edge in edges:
        v0 = object.data.vertices[edge.vertices[0]]
        v1 = object.data.vertices[edge.vertices[1]]
        x2 = (v0.co[0] - v1.co[0]) ** 2
        y2 = (v0.co[1] - v1.co[1]) ** 2
        z2 = (v0.co[2] - v1.co[2]) ** 2
        lengths.append((x2 + y2 + z2) ** 0.5)
    average_length = sum(lengths) / len(lengths)
    return average_length


def generate_SMD_lines():
    empty_SMD_lines = list()
    empty_SMD_lines.append("version 1\n")
    empty_SMD_lines.append("nodes\n")
    empty_SMD_lines.append('0 "root" -1\n')
    empty_SMD_lines.append("end\n")
    empty_SMD_lines.append("skeleton\n")
    empty_SMD_lines.append("time 0\n")
    empty_SMD_lines.append("0 0 0 0 0 0 0\n")
    empty_SMD_lines.append("end\n")
    empty_SMD_lines.append("triangles\n")
    empty_SMD_lines.append("phys\n")
    empty_SMD_lines.append(
        "0  23.812263 -23.812263 25.878662  -0.577350 0.577350 -0.577350  1.000000 0.000000 0\n")
    empty_SMD_lines.append(
        "0  -23.812263 -23.812263 25.878662  0.577350 0.577350 -0.577350  0.000000 0.000000 0\n")
    empty_SMD_lines.append(
        "0  -23.812263 23.812263 25.878662  0.577350 -0.577350 -0.577350  0.000000 1.000000 0\n")
    empty_SMD_lines.append("phys\n")
    empty_SMD_lines.append(
        "0  23.812263 -23.812263 25.878662  -0.577350 0.577350 -0.577350  1.000000 0.000000 0\n")
    empty_SMD_lines.append(
        "0  -23.812263 23.812263 25.878662  0.577350 -0.577350 -0.577350  0.000000 1.000000 0\n")
    empty_SMD_lines.append(
        "0  23.812263 23.812263 25.878662  -0.577350 -0.577350 -0.577350  1.000000 1.000000 0\n")
    empty_SMD_lines.append("phys\n")
    empty_SMD_lines.append(
        "0  23.812263 -23.812263 -25.879150  -0.577350 0.577350 0.577350  1.000000 0.000000 0\n")
    empty_SMD_lines.append(
        "0  -23.812263 23.812263 -25.879150  0.577350 -0.577350 0.577350  0.000000 1.000000 0\n")
    empty_SMD_lines.append(
        "0  -23.812263 -23.812263 -25.879150  0.577350 0.577350 0.577350  0.000000 0.000000 0\n")
    empty_SMD_lines.append("phys\n")
    empty_SMD_lines.append(
        "0  23.812263 -23.812263 -25.879150  -0.577350 0.577350 0.577350  1.000000 0.000000 0\n")
    empty_SMD_lines.append(
        "0  23.812263 23.812263 -25.879150  -0.577350 -0.577350 0.577350  1.000000 1.000000 0\n")
    empty_SMD_lines.append(
        "0  -23.812263 23.812263 -25.879150  0.577350 -0.577350 0.577350  0.000000 1.000000 0\n")
    empty_SMD_lines.append("phys\n")
    empty_SMD_lines.append(
        "0  -23.812263 23.812263 25.878662  0.577350 -0.577350 -0.577350  0.000000 1.000000 0\n")
    empty_SMD_lines.append(
        "0  23.812263 23.812263 -25.879150  -0.577350 -0.577350 0.577350  1.000000 1.000000 0\n")
    empty_SMD_lines.append(
        "0  23.812263 23.812263 25.878662  -0.577350 -0.577350 -0.577350  1.000000 1.000000 0\n")
    empty_SMD_lines.append("phys\n")
    empty_SMD_lines.append(
        "0  23.812263 -23.812263 25.878662  -0.577350 0.577350 -0.577350  1.000000 0.000000 0\n")
    empty_SMD_lines.append(
        "0  -23.812263 -23.812263 -25.879150  0.577350 0.577350 0.577350  0.000000 0.000000 0\n")
    empty_SMD_lines.append(
        "0  -23.812263 -23.812263 25.878662  0.577350 0.577350 -0.577350  0.000000 0.000000 0\n")
    empty_SMD_lines.append("phys\n")
    empty_SMD_lines.append(
        "0  23.812263 23.812263 25.878662  -0.577350 -0.577350 -0.577350  1.000000 1.000000 0\n")
    empty_SMD_lines.append(
        "0  23.812263 -23.812263 -25.879150  -0.577350 0.577350 0.577350  1.000000 0.000000 0\n")
    empty_SMD_lines.append(
        "0  23.812263 -23.812263 25.878662  -0.577350 0.577350 -0.577350  1.000000 0.000000 0\n")
    empty_SMD_lines.append("phys\n")
    empty_SMD_lines.append(
        "0  -23.812263 -23.812263 25.878662  0.577350 0.577350 -0.577350  0.000000 0.000000 0\n")
    empty_SMD_lines.append(
        "0  -23.812263 23.812263 -25.879150  0.577350 -0.577350 0.577350  0.000000 1.000000 0\n")
    empty_SMD_lines.append(
        "0  -23.812263 23.812263 25.878662  0.577350 -0.577350 -0.577350  0.000000 1.000000 0\n")
    empty_SMD_lines.append("phys\n")
    empty_SMD_lines.append(
        "0  -23.812263 23.812263 25.878662  0.577350 -0.577350 -0.577350  0.000000 1.000000 0\n")
    empty_SMD_lines.append(
        "0  -23.812263 23.812263 -25.879150  0.577350 -0.577350 0.577350  0.000000 1.000000 0\n")
    empty_SMD_lines.append(
        "0  23.812263 23.812263 -25.879150  -0.577350 -0.577350 0.577350  1.000000 1.000000 0\n")
    empty_SMD_lines.append("phys\n")
    empty_SMD_lines.append(
        "0  23.812263 -23.812263 25.878662  -0.577350 0.577350 -0.577350  1.000000 0.000000 0\n")
    empty_SMD_lines.append(
        "0  23.812263 -23.812263 -25.879150  -0.577350 0.577350 0.577350  1.000000 0.000000 0\n")
    empty_SMD_lines.append(
        "0  -23.812263 -23.812263 -25.879150  0.577350 0.577350 0.577350  0.000000 0.000000 0\n")
    empty_SMD_lines.append("phys\n")
    empty_SMD_lines.append(
        "0  23.812263 23.812263 25.878662  -0.577350 -0.577350 -0.577350  1.000000 1.000000 0\n")
    empty_SMD_lines.append(
        "0  23.812263 23.812263 -25.879150  -0.577350 -0.577350 0.577350  1.000000 1.000000 0\n")
    empty_SMD_lines.append(
        "0  23.812263 -23.812263 -25.879150  -0.577350 0.577350 0.577350  1.000000 0.000000 0\n")
    empty_SMD_lines.append("phys\n")
    empty_SMD_lines.append(
        "0  -23.812263 -23.812263 25.878662  0.577350 0.577350 -0.577350  0.000000 0.000000 0\n")
    empty_SMD_lines.append(
        "0  -23.812263 -23.812263 -25.879150  0.577350 0.577350 0.577350  0.000000 0.000000 0\n")
    empty_SMD_lines.append(
        "0  -23.812263 23.812263 -25.879150  0.577350 -0.577350 0.577350  0.000000 1.000000 0\n")
    empty_SMD_lines.append("end\n")
    return empty_SMD_lines


def generate_QC_lines(obj, models_dir, mats_dir, surfaceprop):
    QC_template = list()
    QC_template.append(f'$modelname "{models_dir}{obj.name}.mdl"\n')
    QC_template.append(f'$scale 1\n')
    QC_template.append(f'$body {obj.name} "Empty.smd"\n')
    QC_template.append(f'$surfaceprop "{surfaceprop.lower()}"\n')
    QC_template.append('$staticprop\n')
    QC_template.append(f'$cdmaterials "{mats_dir}"\n')
    QC_template.append('$sequence ref "Empty.smd"\n')
    QC_template.append(f'$collisionmodel "{obj.name}.smd"\n')
    QC_template.append('{\n')
    QC_template.append('\t$concave\n')
    QC_template.append('\t$automass\n')
    QC_template.append('}\n')

    # Overrides
    qc_overrides_keys, qc_overrides_values = list(), list()

    qc_overrides_keys = [prop for prop in obj.keys() if not prop.startswith("_RNA_UI") and prop[0] == "$"]
    qc_overrides_values = [obj[prop] for prop in obj.keys() if not prop.startswith("_RNA_UI") and prop[0] == "$"]

    qc_overrides = {qc_overrides_keys[i]: qc_overrides_values[i] for i in range(len(qc_overrides_keys))}

    # Check if any of the override commands already exist, and if so, replace the existing one with the override
    existing_overrides = []
    for override in qc_overrides.keys():
        for line in QC_template:
            if override in line:
                QC_template[QC_template.index(line)] = f'{override} {str(qc_overrides[override])}\n'
                # line = f"test lol {str(2+4)}"
                existing_overrides.append(override)

    # Clean up the override list by removing the ones that already existed in the template
    for override in existing_overrides:
        del qc_overrides[override]

    if len(qc_overrides.keys()) > 0:
        QC_template.append('\n')
        QC_template.append('# Overrides')
        QC_template.append('\n')

        # Add any remaining commands
        for override in qc_overrides.keys():
            QC_template.append('\n')
            QC_template.append(f'{override} {str(qc_overrides[override])}\n')

    return QC_template

def bmesh_walk_hull(vert):
    ''' Walk all un-tagged linked verts '''
    vert.tag = True
    yield(vert)

    linked_verts = list()
    try:
        for e in vert.link_edges:
            if not e.other_vert(vert).tag:
                linked_verts.append(e.other_vert(vert))
    except:
        pass

    for v in linked_verts:
        if v.tag:
            continue
        yield from bmesh_walk_hull(v)


def bmesh_get_hulls(bm, verts=[]):
    bm.verts.ensure_lookup_table()
    bm.edges.ensure_lookup_table()
    bm.faces.ensure_lookup_table()
    def tag(verts, switch):
        for v in verts:
            v.tag = switch
    tag(bm.verts, True)
    tag(verts, False)
    hulls = list()
    verts = set(verts)
    while verts:
        v = verts.pop()
        verts.add(v)
        hull = set(bmesh_walk_hull(v))
        hulls.append(list(hull))
        tag(hull, False)  # remove tag = True
        verts -= hull
    return hulls


def bmesh_join(target_bm, source_bm):
    '''
    source_bm into target_bm
    returns target_bm with added geometry, if source_bm is not empty.
    '''
    target_bm.verts.ensure_lookup_table()
    source_bm.verts.ensure_lookup_table()

    source_bm.verts.layers.int.new('index')
    idx_layer = source_bm.verts.layers.int['index']

    for face in source_bm.faces:
        new_verts = []
        for old_vert in face.verts:
            if not old_vert.tag:
                new_vert = target_bm.verts.new(old_vert.co)
                target_bm.verts.index_update()
                old_vert[idx_layer] = new_vert.index
                old_vert.tag = True

            target_bm.verts.ensure_lookup_table()
            idx = old_vert[idx_layer]
            new_verts.append(target_bm.verts[idx])

        target_bm.faces.new(new_verts)
    return target_bm

def get_3d_viewport():
    ''' Function to get the 3D view context '''
    for area in bpy.context.screen.areas:
        if area.type == 'VIEW_3D':
                return area
    return None

def force_convex(objs):
    if len(objs) >= 1:
        for obj in objs:
            obj.select_set(False)

        total_hull_count = 0

        for obj in objs:
            bpy.ops.object.select_all(action='DESELECT')

            bpy.context.view_layer.objects.active = obj
            obj.select_set(True)

            original_name = obj.name

            # Make sure no faces are selected
            bpy.ops.object.mode_set(mode='EDIT')
            bpy.ops.mesh.reveal()
            bpy.ops.mesh.select_mode(type='VERT')
            bpy.ops.mesh.select_all(action='DESELECT')
            bpy.ops.object.mode_set(mode='OBJECT')
            bpy.ops.object.transform_apply(
                location=False, rotation=True, scale=True)

            # Select all hulls and separate them into separate objects
            bpy.ops.object.mode_set(mode='EDIT')
            bpy.ops.mesh.select_all(action='SELECT')
            bpy.ops.mesh.dissolve_limited(
                angle_limit=0.0872665, delimit={'NORMAL'})
            bpy.ops.mesh.quads_convert_to_tris(
                quad_method='BEAUTY', ngon_method='BEAUTY')
            bpy.ops.mesh.normals_make_consistent(inside=False)
            bpy.ops.mesh.select_all(action='DESELECT')
            bpy.ops.object.mode_set(mode='OBJECT')

            # Begin Bmesh processing
            me = obj.data
            bm = bmesh.new()
            bm_processed = bmesh.new()

            bm.from_mesh(me)
            hulls = [hull for hull in bmesh_get_hulls(
                bm, verts=bm.verts)]

            # Create individual hull bmeshes
            for hull in hulls:
                bm_hull = bmesh.new()

                # Add vertices to individual bmesh hull
                for vert in hull:
                    bmesh.ops.create_vert(bm_hull, co=vert.co)

                # Generate convex hull
                ch = bmesh.ops.convex_hull(
                    bm_hull, input=bm_hull.verts, use_existing_faces=False)
                bmesh.ops.delete(
                    bm_hull,
                    geom=list(set(ch["geom_unused"] + ch["geom_interior"])),
                    context='VERTS')

                # Add the processed hull to the new main object, which will store all of them
                bmesh_join(bm_processed, bm_hull)
                total_hull_count += 1
                bm_hull.clear()
                bm_hull.free()

            bm_processed.to_mesh(me)
            me.update()
            bm.clear()
            bm.free()
            bm_processed.clear()
            bm_processed.free()

            # End Bmesh processing

            # Rejoin and clean up
            obj.name = original_name
            bpy.ops.object.transform_apply(
                location=False, rotation=True, scale=True)
            bpy.ops.object.shade_smooth()

            # Remove non-manifolds
            bpy.ops.object.mode_set(mode='EDIT')
            bpy.ops.mesh.select_mode(
                use_extend=False, use_expand=False, type='VERT')
            bpy.ops.mesh.select_all(action='DESELECT')
            bpy.ops.mesh.select_non_manifold()
            bpy.ops.mesh.select_linked(delimit=set())
            bpy.ops.mesh.delete(type='VERT')
            bpy.ops.mesh.select_all(action='DESELECT')
            bpy.ops.mesh.select_all(action='SELECT')
            bpy.ops.mesh.normals_make_consistent(inside=False)
            bpy.ops.mesh.select_all(action='DESELECT')
            bpy.ops.object.mode_set(mode='OBJECT')
            
    return total_hull_count

def set_origin(location):
    saved_location = bpy.context.scene.cursor.location
    bpy.context.scene.cursor.location = location
    bpy.ops.object.origin_set(type='ORIGIN_CURSOR')
    bpy.context.scene.cursor.location = saved_location

def count_loose_geometry(obj):
    
    bm = bmesh.new()
    bm.from_mesh(obj.data)
    
    # Get all loose parts by finding connected vertices
    bm.verts.ensure_lookup_table()
    bm.edges.ensure_lookup_table()
    bm.faces.ensure_lookup_table()
    
    # Tag all vertices as not visited
    visited = set()
    island_count = 0
    
    # Iterate through all vertices
    for vert in bm.verts:
        if vert.index not in visited:
            # Found a new island
            island_count += 1
            # Do a BFS to find all connected vertices
            queue = [vert]
            while queue:
                current_vert = queue.pop()
                if current_vert.index not in visited:
                    visited.add(current_vert.index)
                    # Add all connected vertices to queue
                    for edge in current_vert.link_edges:
                        linked_vert = edge.other_vert(current_vert)
                        if linked_vert.index not in visited:
                            queue.append(linked_vert)
    
    # Clean up
    bm.free()
    
    return island_count

def isnan(var):
    return var != var

def get_hull_volumes(obj):
    """Calculate volumes of all convex hulls in the mesh."""
    if not obj or obj.type != 'MESH':
        return None

    bm = bmesh.new()
    bm.from_mesh(obj.data)
    bm.faces.ensure_lookup_table()

    hull_islands = []
    visited = set()

    for face in bm.faces:
        if face.index in visited:
            continue

        # Get all connected faces (this island)
        island_faces = []
        face_indices = set()
        stack = [face]

        while stack:
            current_face = stack.pop()
            if current_face.index in visited:
                continue
            visited.add(current_face.index)
            island_faces.append(current_face)
            face_indices.add(current_face.index)

            # Add adjacent faces
            for edge in current_face.edges:
                for neighbor in edge.link_faces:
                    if neighbor.index not in visited:
                        stack.append(neighbor)

        # Store face indices and BMesh faces (temporarily)
        hull_islands.append((face_indices, island_faces))

    # Calculate volume for each hull
    hull_volumes = []
    for face_indices, island_faces in hull_islands:
        # Create a temporary BMesh to calculate volume
        temp_bm = bmesh.new()
        vert_map = {}  # To maintain vertex sharing
        
        for face in island_faces:
            new_verts = []
            for v in face.verts:
                if v.index not in vert_map:
                    vert_map[v.index] = temp_bm.verts.new(v.co)
                new_verts.append(vert_map[v.index])
            temp_bm.faces.new(new_verts)
        
        # Calculate volume
        temp_bm.faces.ensure_lookup_table()
        temp_bm.verts.ensure_lookup_table()
        volume = temp_bm.calc_volume()
        temp_bm.free()
        
        if not isnan(volume):
            hull_volumes.append((face_indices, volume))

    bm.free()
    return hull_volumes

def select_thin_hulls(obj, threshold=0.01):
    """Selects thin hulls based on volume threshold."""
    hull_volumes = get_hull_volumes(obj)
    if not hull_volumes:
        print("No valid hulls found")
        return False

    # Calculate average volume
    total_volume = sum(vol for _, vol in hull_volumes)
    avg_volume = total_volume / len(hull_volumes)
    print(f"Average hull volume: {avg_volume}")

    # Find thin hulls (volume <= threshold * average)
    thin_face_indices = set()
    thin_hull_count = 0
    for face_indices, volume in hull_volumes:
        if volume <= threshold * avg_volume:
            thin_face_indices.update(face_indices)
            thin_hull_count += 1

    if not thin_face_indices:
        print("No thin hulls found")
        return 0

    print(f"Found {len(thin_face_indices)} faces in thin hulls (<= {threshold*100}% of average volume)")

    # Switch to edit mode and select thin hulls
    bpy.ops.object.mode_set(mode='EDIT')
    bpy.ops.mesh.reveal()
    bpy.ops.mesh.select_mode(type='FACE')
    bpy.ops.mesh.select_all(action='DESELECT')

    # Select thin faces using their indices
    bm = bmesh.from_edit_mesh(obj.data)
    bm.faces.ensure_lookup_table()
    
    for face in bm.faces:
        if face.index in thin_face_indices:
            face.select = True

    bmesh.update_edit_mesh(obj.data)
    bpy.ops.object.mode_set(mode='OBJECT')

    return thin_hull_count


# Generate Collision Mesh operator


class GenerateFromFaces(bpy.types.Operator):
    """Generate a Source Engine-compliant collision model for all selected mesh objects, based on their polygon faces. The original object(s) will be temporarily hidden, but not modified otherwise"""
    bl_idname = "object.src_eng_gen_faces"
    bl_label = "Generate Collision from Faces"
    bl_options = {'REGISTER'}

    def execute(self, context):

        objs = check_for_selected()
        if objs == False or get_current_mode() != "OBJECT":
            display_msg_box(
                "At least one valid mesh object must be selected, in Object Mode.", "Info", "INFO")

            return {'FINISHED'}

        original_undo = bpy.context.preferences.edit.use_global_undo
        bpy.context.preferences.edit.use_global_undo = False

        obj_results = []

        if len(objs) >= 1:
            for obj in objs:
                obj.select_set(False)

            total_hull_count = 0
            extrude_modifier = (-1) * \
                bpy.context.scene.SrcEngCollProperties.Extrusion_Modifier
            merge_distance = bpy.context.scene.SrcEngCollProperties.Merge_Distance
            original_pivot = bpy.context.scene.tool_settings.transform_pivot_point

            for obj in objs:
                bpy.ops.object.select_all(action='DESELECT')
                root_collection = None
                if 'Collision Models' in bpy.data.collections.keys():
                    root_collection = bpy.data.collections['Collision Models']
                else:
                    root_collection = bpy.data.collections.new("Collision Models")
                    bpy.context.scene.collection.children.link(root_collection)

                obj_collections = [
                    c for c in bpy.data.collections if obj.name in c.objects.keys()]

                obj_phys = None
                collection_phys = None

                bpy.ops.object.mode_set(mode="OBJECT")
                bpy.context.view_layer.objects.active = obj
                obj.select_set(True)

                if (obj.name + "_phys") in bpy.data.objects.keys():
                    bpy.data.objects.remove(bpy.data.objects[obj.name + "_phys"])

                bpy.ops.object.duplicate(linked=False)
                obj.hide_set(True)
                obj_phys = bpy.context.active_object
                obj_phys.name = obj.name + "_phys"

                bpy.ops.object.make_single_user(object=True, obdata=True)
                bpy.ops.object.transform_apply(
                    location=True, rotation=True, scale=True)
                bpy.ops.object.shade_smooth()
                bpy.ops.object.mode_set(mode="EDIT")
                bpy.ops.mesh.reveal()
                bpy.ops.mesh.select_all(action='DESELECT')
                bpy.ops.mesh.select_mode(
                    use_extend=False, use_expand=False, type='VERT')
                bpy.ops.mesh.select_all(action='SELECT')
                bpy.ops.mesh.mark_sharp(clear=True)
                bpy.ops.mesh.remove_doubles(threshold=merge_distance)
                if bpy.context.scene.SrcEngCollProperties.Dissolve:
                    bpy.ops.mesh.tris_convert_to_quads(
                        seam=True, sharp=True, materials=True)
                    bpy.ops.mesh.dissolve_limited(
                        angle_limit=0.0872665, delimit={'NORMAL'})

                # Decimate and clean up mesh to minimize unnecessary hulls being generated later
                bpy.ops.mesh.vert_connect_concave()
                bpy.ops.mesh.face_make_planar(repeat=20)
                bpy.ops.mesh.vert_connect_nonplanar()
                bpy.ops.mesh.decimate(
                    ratio=bpy.context.scene.SrcEngCollProperties.Decimate_Ratio)
                bpy.ops.mesh.vert_connect_concave()
                bpy.ops.mesh.vert_connect_nonplanar()

                bpy.ops.mesh.edge_split(type='VERT')
                bpy.ops.mesh.select_all(action='SELECT')

                # Extrude faces
                bpy.ops.mesh.extrude_region_move(MESH_OT_extrude_region={"use_normal_flip": False, "use_dissolve_ortho_edges": False, "mirror": False}, TRANSFORM_OT_translate={"value": (0, 0, 0), "orient_type": 'GLOBAL', "orient_matrix": ((0, 0, 0), (0, 0, 0), (0, 0, 0)), "orient_matrix_type": 'GLOBAL', "constraint_axis": (
                    False, False, False), "mirror": False, "use_proportional_edit": False, "snap": False, "gpencil_strokes": False, "cursor_transform": False, "texture_space": False, "remove_on_cancel": False, "view2d_edge_pan": False, "release_confirm": False, "use_accurate": False, "use_automerge_and_split": False})

                # Move the extruded faces inward
                bpy.context.scene.tool_settings.transform_pivot_point = 'INDIVIDUAL_ORIGINS'
                bpy.ops.transform.shrink_fatten(value=(
                    extrude_modifier), use_even_offset=False, mirror=True, use_proportional_edit=False, snap=False)

                bpy.ops.mesh.select_all(action='SELECT')
                bpy.ops.mesh.normals_make_consistent(inside=False)
                bpy.ops.object.mode_set(mode='OBJECT')
                bpy.ops.object.shade_smooth()

                # Setup collection
                if (obj_phys.name.lower()) in bpy.data.collections.keys():
                    collection_phys = bpy.data.collections[obj_phys.name.lower()]
                else:
                    collection_phys = bpy.data.collections.new(obj_phys.name.lower())
                    root_collection.children.link(collection_phys)

                collection_phys.objects.link(obj_phys)

                # Unlink the new collision model from other collections
                for c in obj_collections:
                    if obj_phys.name in c.objects.keys():
                        c.objects.unlink(obj_phys)
                if obj_phys.name in bpy.context.scene.collection.objects.keys():
                    bpy.context.scene.collection.objects.unlink(obj_phys)

                bpy.ops.object.mode_set(mode='OBJECT')

                # Begin Bmesh processing
                me = obj_phys.data
                bm = bmesh.new()
                bm_processed = bmesh.new()

                bm.from_mesh(me)
                hulls = [hull for hull in bmesh_get_hulls(
                    bm, verts=bm.verts)]

                # Create individual hull bmeshes
                for hull in hulls:
                    bm_hull = bmesh.new()

                    # Add vertices to individual bmesh hull
                    for vert in hull:
                        bmesh.ops.create_vert(bm_hull, co=vert.co)

                    # Generate convex hull
                    ch = bmesh.ops.convex_hull(
                        bm_hull, input=bm_hull.verts, use_existing_faces=False)
                    bmesh.ops.delete(
                        bm_hull,
                        geom=list(set(ch["geom_unused"] + ch["geom_interior"])),
                        context='VERTS')

                    # Add the processed hull to the new main object, which will store all of them
                    bm_processed = bmesh_join(bm_processed, bm_hull)
                    if not bpy.context.scene.SrcEngCollProperties.Post_Merge:
                        total_hull_count += 1
                    bm_hull.clear()
                    bm_hull.free()

                bm_processed.to_mesh(me)
                me.update()
                bm.clear()
                bm.free()
                bm_processed.clear()
                bm_processed.free()

                # End Bmesh processing

                # Recombine into one object
                bpy.ops.object.mode_set(mode='OBJECT')
                obj_phys.name = obj.name.lower() + "_phys"
                bpy.ops.object.shade_smooth()

                # Remove non-manifold and degenerates
                bpy.ops.object.mode_set(mode='EDIT')
                bpy.ops.mesh.select_mode(
                    use_extend=False, use_expand=False, type='VERT')
                bpy.ops.mesh.select_all(action='DESELECT')
                bpy.ops.mesh.select_non_manifold()
                bpy.ops.mesh.select_linked(delimit=set())
                bpy.ops.mesh.delete(type='VERT')

                # Cleanup materials
                bpy.ops.object.mode_set(mode='OBJECT')
                bpy.context.active_object.data.materials.clear()
                if "phys" not in bpy.data.materials.keys():
                    bpy.data.materials.new("phys")
                bpy.context.active_object.data.materials.append(
                    bpy.data.materials["phys"])
                bpy.context.active_object.data.materials[0].diffuse_color = (
                    1, 0, 0.78315, 1)

                # Finalize transforms and restore the original object's origin point
                bpy.ops.object.transform_apply(
                    location=False, rotation=True, scale=True)
                bpy.context.scene.cursor.location = tuple(obj.location)
                bpy.ops.object.origin_set(type='ORIGIN_CURSOR', center='MEDIAN')

                # Optional post-merge
                if bpy.context.scene.SrcEngCollProperties.Post_Merge:
                    bpy.ops.object.mode_set(mode='EDIT')
                    bpy.ops.mesh.select_all(action='SELECT')
                    bpy.ops.mesh.select_mode(use_extend=False, use_expand=False, type='VERT')
                    bpy.ops.mesh.remove_doubles(threshold=merge_distance)
                    bpy.ops.object.mode_set(mode='OBJECT')
                    force_convex([bpy.context.active_object])
                    bm = bmesh.new()
                    bm.from_mesh(bpy.context.active_object.data)
                    total_hull_count = len([hull for hull in bmesh_get_hulls(bm, verts=bm.verts)])
                    bm.clear()
                    bm.free()
                
                obj_results.append(obj_phys.name)
                obj.select_set(False)

            bpy.context.scene.tool_settings.transform_pivot_point = original_pivot

            display_msg_box(
                "Generated collision mesh(es) with total hull count of " + str(total_hull_count) + ".", "Info", "INFO")

        for obj in obj_results:
            bpy.data.objects[obj].select_set(True)
            
        bpy.context.preferences.edit.use_global_undo = original_undo

        return {'FINISHED'}
    
# Generate UV-based Collision operator


class GenerateFromUVMap(bpy.types.Operator):
    """Generate a collision model for every selected mesh object, based on the original mesh's UV Map. A collision hull is generated for every UV island"""
    bl_idname = "object.src_eng_gen_uvmap"
    bl_label = "Generate Collision via UV Map"
    bl_options = {'REGISTER'}

    def execute(self, context):
        objs = check_for_selected()
        if objs == False or get_current_mode() != "OBJECT":
            display_msg_box(
                "At least one mesh object must be selected, in Object Mode.", "Info", "INFO")

            return {'FINISHED'}

        original_undo = bpy.context.preferences.edit.use_global_undo
        bpy.context.preferences.edit.use_global_undo = False

        obj_results = []

        if len(objs) >= 1:
            for obj in objs:
                obj.select_set(False)

            total_hull_count = 0
            merge_distance = bpy.context.scene.SrcEngCollProperties.Merge_Distance

            for obj in objs:

                # Check if this mesh object even has a UV Map first. If it doesn't, skip it.
                if len(obj.data.uv_layers) == 0:
                    continue

                bpy.ops.object.select_all(action='DESELECT')
                root_collection = None
                if 'Collision Models' in bpy.data.collections.keys():
                    root_collection = bpy.data.collections['Collision Models']
                else:
                    root_collection = bpy.data.collections.new("Collision Models")
                    bpy.context.scene.collection.children.link(root_collection)

                obj_collections = [
                    c for c in bpy.data.collections if obj.name in c.objects.keys()]

                obj_phys = None
                collection_phys = None

                bpy.ops.object.mode_set(mode="OBJECT")
                bpy.context.view_layer.objects.active = obj
                obj.select_set(True)

                if (obj.name + "_phys") in bpy.data.objects.keys():
                    bpy.data.objects.remove(bpy.data.objects[obj.name + "_phys"])

                bpy.ops.object.duplicate(linked=False)
                obj.hide_set(True)
                obj_phys = bpy.context.active_object
                obj_phys.name = obj.name + "_phys"

                bpy.ops.object.make_single_user(object=True, obdata=True)
                bpy.ops.object.transform_apply(
                    location=True, rotation=True, scale=True)
                bpy.ops.object.shade_smooth()
                
                # Split up object based on UV seams
                bpy.ops.object.mode_set(mode="EDIT")
                bpy.ops.mesh.reveal()
                bpy.ops.mesh.select_all(action='SELECT')
                bpy.ops.mesh.remove_doubles(threshold=merge_distance)
                bpy.ops.uv.select_all(action='SELECT')
                bpy.ops.uv.seams_from_islands()
                bpy.ops.mesh.select_all(action='DESELECT')
                bpy.ops.uv.select_all(action='DESELECT')
                bpy.ops.object.mode_set(mode="OBJECT")

                seams = [edge for edge in bpy.context.active_object.data.edges if edge.use_seam]
                for seam in seams:
                        seam.select = True
                    
                bpy.ops.object.mode_set(mode='EDIT')
                bpy.ops.mesh.edge_split(type='EDGE')
                bpy.ops.object.mode_set(mode='OBJECT')

                force_convex([obj_phys])

                bpy.ops.object.mode_set(mode="EDIT")
                bpy.ops.mesh.reveal()
                bpy.ops.mesh.select_all(action='DESELECT')
                bpy.ops.mesh.select_mode(
                    use_extend=False, use_expand=False, type='VERT')
                bpy.ops.mesh.select_all(action='SELECT')

                if bpy.context.scene.SrcEngCollProperties.Dissolve:
                    bpy.ops.mesh.tris_convert_to_quads(
                        seam=True, sharp=True, materials=True)
                    bpy.ops.mesh.dissolve_limited(
                        angle_limit=0.0872665, delimit={'NORMAL'})

                # Clean up mesh to minimize unnecessary hulls being generated later
                bpy.ops.mesh.vert_connect_concave()
                bpy.ops.mesh.face_make_planar(repeat=20)
                bpy.ops.mesh.vert_connect_nonplanar()
                bpy.ops.mesh.vert_connect_concave()
                bpy.ops.mesh.vert_connect_nonplanar()
                bpy.ops.mesh.decimate(
                    ratio=bpy.context.scene.SrcEngCollProperties.Decimate_Ratio)
                bpy.ops.mesh.select_all(action='SELECT')
                bpy.ops.mesh.normals_make_consistent(inside=False)
                bpy.ops.object.mode_set(mode='OBJECT')
                bpy.ops.object.shade_smooth()

                # Setup collection
                if (obj_phys.name.lower()) in bpy.data.collections.keys():
                    collection_phys = bpy.data.collections[obj_phys.name.lower()]
                else:
                    collection_phys = bpy.data.collections.new(obj_phys.name.lower())
                    root_collection.children.link(collection_phys)

                collection_phys.objects.link(obj_phys)

                # Unlink the new collision model from other collections
                for c in obj_collections:
                    if obj_phys.name in c.objects.keys():
                        c.objects.unlink(obj_phys)
                if obj_phys.name in bpy.context.scene.collection.objects.keys():
                    bpy.context.scene.collection.objects.unlink(obj_phys)

                bpy.ops.object.mode_set(mode='OBJECT')

                force_convex([bpy.context.active_object])
                bm = bmesh.new()
                bm.from_mesh(bpy.context.active_object.data)
                total_hull_count += len([hull for hull in bmesh_get_hulls(bm, verts=bm.verts)])
                bm.clear()
                bm.free()

                # Cleanup materials
                bpy.ops.object.mode_set(mode='OBJECT')
                bpy.context.active_object.data.materials.clear()
                if "phys" not in bpy.data.materials.keys():
                    bpy.data.materials.new("phys")
                bpy.context.active_object.data.materials.append(
                    bpy.data.materials["phys"])
                bpy.context.active_object.data.materials[0].diffuse_color = (
                    1, 0, 0.78315, 1)

                # Finalize transforms and restore the original object's origin point
                bpy.ops.object.transform_apply(
                    location=False, rotation=True, scale=True)
                bpy.context.scene.cursor.location = tuple(obj.location)
                bpy.ops.object.origin_set(type='ORIGIN_CURSOR', center='MEDIAN')
                
                # Optional post-merge
                if bpy.context.scene.SrcEngCollProperties.Post_Merge:
                    bpy.ops.object.mode_set(mode='EDIT')
                    bpy.ops.mesh.select_all(action='SELECT')
                    bpy.ops.mesh.select_mode(use_extend=False, use_expand=False, type='VERT')
                    bpy.ops.mesh.remove_doubles(threshold=merge_distance)
                    bpy.ops.object.mode_set(mode='OBJECT')
                    
                obj_results.append(obj_phys.name)
                obj.select_set(False)

        display_msg_box(
            "Generated collision mesh(es) with total hull count of " + str(total_hull_count) + ".", "Info", "INFO")

        for obj in obj_results:
            bpy.data.objects[obj].select_set(True)

        bpy.context.preferences.edit.use_global_undo = original_undo

        return {'FINISHED'}

# Fracture Generator operator

class GenerateFromFracture(bpy.types.Operator):
    """Produces a more accurate collision mesh that conforms better to the original shape. Works best on competely sealed objects with no holes. Requires the Cell Fracture addon to be enabled in Blender preferences"""
    bl_idname = "object.src_eng_gen_fracture"
    bl_label = "Generate Collision via Fracture"
    bl_options = {'REGISTER'}

    def execute(self, context):
        original_undo = bpy.context.preferences.edit.use_global_undo
        bpy.context.preferences.edit.use_global_undo = False

        # Check for Cell Fracture addon (dependency)
        try:
            bpy.ops.object.add_fracture_cell_objects(source={})
        except AttributeError:
            display_msg_box(
                "You must first enable the Cell Fracture addon in your Blender preferences. It's required by this feature.", "Error", "ERROR")
            
            bpy.context.preferences.edit.use_global_undo = original_undo
            return {'FINISHED'}
        
        except TypeError:
            print("\nCell fracture addon found.\n")
        
        objs = check_for_selected()
        if objs == False or get_current_mode() != "OBJECT":

            display_msg_box(
                "At least one mesh object must be selected, in Object Mode.", "Info", "INFO")
            
            bpy.context.preferences.edit.use_global_undo = original_undo
            return {'FINISHED'}

        obj_results = []

        if len(objs) >= 1:
            fracture_target = bpy.context.scene.SrcEngCollProperties.Fracture_Target
            voxel_res = bpy.context.scene.SrcEngCollProperties.Voxel_Resolution
            gap_width = bpy.context.scene.SrcEngCollProperties.Fracture_Gap
            total_hull_count = 0
            
            for obj in objs:
                obj.select_set(False)

            for obj in objs:
                bpy.ops.object.select_all(action='DESELECT')

                root_collection = None
                if 'Collision Models' in bpy.data.collections.keys():
                    root_collection = bpy.data.collections['Collision Models']
                else:
                    root_collection = bpy.data.collections.new("Collision Models")
                    bpy.context.scene.collection.children.link(root_collection)
                original_collection = bpy.context.collection

                obj_collections = [
                    c for c in bpy.data.collections if obj.name in c.objects.keys()]

                obj_phys = None
                collection_phys = None

                bpy.ops.object.mode_set(mode="OBJECT")
                bpy.context.view_layer.objects.active = obj
                obj.select_set(True)

                if (obj.name + "_phys") in bpy.data.objects.keys():
                    bpy.data.objects.remove(bpy.data.objects[obj.name + "_phys"])

                obj_phys = obj.copy()
                obj_phys.name = obj.name.lower() + "_phys"
                bpy.context.collection.objects.link(obj_phys)
                obj.select_set(False)
                obj.hide_set(True)
                obj_phys.select_set(True)
                bpy.context.view_layer.objects.active = obj_phys

                bpy.ops.object.make_single_user(object=True, obdata=True)
                bpy.ops.object.transform_apply(
                    location=False, rotation=True, scale=True)
                bpy.ops.object.shade_smooth()

                # Voxel remesh
                remesh = obj_phys.modifiers.new(name="RM", type="REMESH")
                remesh.voxel_size = voxel_res
                bpy.ops.object.convert(target='MESH')
                
                # Cell Fracture, based on the Fracture Target set by user
                bpy.ops.object.add_fracture_cell_objects(source={'VERT_OWN'}, source_limit=fracture_target, recursion=0, use_smooth_faces=False, use_sharp_edges=False, use_sharp_edges_apply=False, use_data_match=False, use_island_split=False, margin=gap_width, material_index=0, use_interior_vgroup=False, use_recenter=False, use_debug_redraw=False)
                bpy.context.view_layer.objects.active = bpy.context.selected_objects[0]
                bpy.ops.object.join()
                bpy.data.objects.remove(obj_phys)
                obj_phys = bpy.context.active_object

                # Decimate loop
                if len(obj.data.polygons) > 100:
                    while len(obj_phys.data.polygons) > (len(obj.data.polygons) * 1.5):
                        bpy.ops.object.mode_set(mode="EDIT")
                        bpy.ops.mesh.select_all(action='SELECT')
                        bpy.ops.mesh.decimate(ratio=0.75)
                        bpy.ops.mesh.select_all(action='DESELECT')
                        bpy.ops.object.mode_set(mode="OBJECT")

                # Decimate and Limited dissolve
                bpy.ops.object.mode_set(mode="EDIT")
                bpy.ops.mesh.select_all(action='SELECT')
                bpy.ops.mesh.decimate(
                    ratio=bpy.context.scene.SrcEngCollProperties.Decimate_Ratio)
                bpy.ops.mesh.dissolve_limited(
                    angle_limit=0.16, delimit={'NORMAL'})
                bpy.ops.mesh.quads_convert_to_tris(
                    quad_method='BEAUTY', ngon_method='BEAUTY')
                bpy.ops.object.mode_set(mode="OBJECT")
            
                force_convex([obj_phys])

                # Begin finalizing
                bpy.ops.object.mode_set(mode='OBJECT')
                obj_phys.name = obj.name.lower() + "_phys"
                bpy.ops.object.shade_smooth()
                obj.hide_set(True)
                bpy.ops.object.transform_apply(
                    location=False, rotation=True, scale=True)
                
                # Setup collection
                if (obj_phys.name.lower()) in bpy.data.collections.keys():
                    collection_phys = bpy.data.collections[obj_phys.name.lower()]
                else:
                    collection_phys = bpy.data.collections.new(obj_phys.name)
                    root_collection.children.link(collection_phys)

                if obj_phys.name not in collection_phys.objects.keys():
                    collection_phys.objects.link(obj_phys)

                # Unlink the new collision model from other collections
                original_collection.objects.unlink(obj_phys)
                for c in obj_collections:
                    if obj_phys.name in c.objects.keys():
                        c.objects.unlink(obj_phys)
                if obj_phys.name in bpy.context.scene.collection.objects.keys():
                    bpy.context.scene.collection.objects.unlink(obj_phys)
                
                # Restore original origin point
                new_origin = tuple(obj.location)
                bpy.context.scene.cursor.location = new_origin
                bpy.ops.object.origin_set(type='ORIGIN_CURSOR', center='MEDIAN')

                # Remove non-manifold and degenerates
                bpy.ops.object.mode_set(mode='EDIT')
                bpy.ops.mesh.select_mode(
                    use_extend=False, use_expand=False, type='VERT')
                bpy.ops.mesh.select_all(action='DESELECT')
                bpy.ops.mesh.select_non_manifold()
                bpy.ops.mesh.select_linked(delimit=set())
                bpy.ops.mesh.delete(type='VERT')
                
                # Cleanup materials
                bpy.ops.object.mode_set(mode='OBJECT')
                obj_phys.data.materials.clear()
                if "phys" not in bpy.data.materials.keys():
                    bpy.data.materials.new("phys")
                obj_phys.data.materials.append(
                    bpy.data.materials["phys"])
                obj_phys.data.materials[0].diffuse_color = (
                    1, 0, 0.78315, 1)
                
                obj_results.append(obj_phys.name)
                obj.select_set(False)

            display_msg_box(
                "Generated collision mesh, with total hull count of " + str(total_hull_count) + ".", "Info", "INFO")

        for obj in obj_results:
            bpy.data.objects[obj].select_set(True)

        bpy.context.preferences.edit.use_global_undo = original_undo

        return {'FINISHED'}


class GenerateFromBisection(bpy.types.Operator):
    """Generate a collision model for every selected mesh object, by bisecting each object repeatedly by a specified number of cuts along the X, Y, and/or Z axes"""
    bl_idname = "object.src_eng_gen_bisect"
    bl_label = "Generate Collision via Bisection"
    bl_options = {'REGISTER'}

    def execute(self, context):
        objs = check_for_selected()
        if objs == False or get_current_mode() != "OBJECT":
            display_msg_box(
                "At least one mesh object must be selected, in Object Mode.", "Info", "INFO")

            return {'FINISHED'}
        
        gap_width = bpy.context.scene.SrcEngCollProperties.Bisect_Gap
        cuts = bpy.context.scene.SrcEngCollProperties.Bisections
        slice_mode = bpy.context.scene.SrcEngCollProperties.Bisect_Mode
        merge_distance = bpy.context.scene.SrcEngCollProperties.Merge_Distance
        
        original_undo = bpy.context.preferences.edit.use_global_undo
        bpy.context.preferences.edit.use_global_undo = False

        obj_results = []

        def gen_bisect_setup(obj):
            obj.hide_set(False)

            obj_phys = obj.copy()
            obj_phys.data = obj.data.copy()
            obj_phys.name = obj.name.lower() + "_phys"
            bpy.context.collection.objects.link(obj_phys)
            obj_phys.select_set(True)
            obj.select_set(False)
            obj.hide_set(True)
            bpy.context.view_layer.objects.active = obj_phys
            bpy.ops.object.make_single_user(object=True, obdata=True)
            bpy.ops.object.transform_apply(
                location=False, rotation=True, scale=True)
            set_origin(obj.location)
            bpy.ops.object.shade_smooth()
            bpy.ops.object.convert(target='MESH')

            obj_bbox = obj_phys.copy()
            obj_bbox.data = obj_phys.data.copy()
            bpy.context.collection.objects.link(obj_bbox)
            obj_bbox.name = obj.name.lower() + "_bbox"
            me = obj_bbox.data
            
            obj_phys.select_set(False)
            obj_phys.hide_set(True)
            obj_bbox.select_set(True)
            bpy.context.view_layer.objects.active = obj_bbox
            set_origin(obj.location)
            obj_phys.hide_set(False)
            obj_phys.select_set(True)
            obj_bbox.select_set(False)
            bpy.context.view_layer.objects.active = obj_phys

            bm = bmesh.new()

            verts = [bm.verts.new(b) for b in obj_bbox.bound_box]
            bmesh.ops.convex_hull(bm, input=verts)
            bm.to_mesh(me)
            bm.clear()
            bm.free()
            
            return obj_phys, obj_bbox

        def cull_edges(obj, threshold=0.1, mode="xy"):
            bm = bmesh.new()
            bm.from_mesh(obj.data)
            # Calculate bounding box dimensions
            bbox = [obj.matrix_world @ mathutils.Vector(corner) for corner in obj.bound_box]
            x_dim = max(v.x for v in bbox) - min(v.x for v in bbox)
            y_dim = max(v.y for v in bbox) - min(v.y for v in bbox)
            z_dim = max(v.z for v in bbox) - min(v.z for v in bbox)
            min_edge_length = 0.9 * min(x_dim, y_dim, z_dim)

            edges_to_delete = []

            if mode == "xy":
                for edge in bm.edges:
                    vert1, vert2 = edge.verts
                    vertical_length = abs(vert1.co.z - vert2.co.z)
                    if vertical_length > threshold:
                        edges_to_delete.append(edge)
            
            elif mode == "z":
                # Delete all faces but keep the edges
                bm.faces.ensure_lookup_table()
                bmesh.ops.delete(bm, geom=bm.faces, context='FACES_ONLY')

            edges_to_delete = list(set(edges_to_delete + [edge for edge in bm.edges if edge.calc_length() < min_edge_length]))

            bmesh.ops.delete(bm, geom=edges_to_delete, context='EDGES')
            
            bm.to_mesh(obj.data)
            bm.clear()
            bm.free()

        def auto_bisect(obj, cuts=4, mode="xy"):
            # Ensure we are in object mode
            bpy.ops.object.mode_set(mode='OBJECT')

            # Calculate the object's world-aligned bounding box
            world_bbox = [obj.matrix_world @ mathutils.Vector(corner) for corner in obj.bound_box]
            min_z = min(corner.z for corner in world_bbox)
            max_z = max(corner.z for corner in world_bbox)
            min_y = min(corner.y for corner in world_bbox)
            max_y = max(corner.y for corner in world_bbox)

            # Create a new BMesh to work on the object's mesh data
            bm = bmesh.new()
            bm.from_mesh(obj.data)
            bm.transform(obj.matrix_world)  # Apply the object's transformation matrix to the BMesh

            # Simplify the mesh (optional step)
            bmesh.ops.dissolve_limit(bm, angle_limit=0.0872665, use_dissolve_boundaries=False, verts=bm.verts, edges=bm.edges, delimit={'NORMAL'})

            # Apply bisection based on mode
            if mode == "xy":
                step = (max_z - min_z) / (cuts + 1)
                for i in range(1, cuts + 1):
                    cut_z = min_z + step * i
                    plane_co = mathutils.Vector((0, 0, cut_z))
                    plane_no = mathutils.Vector((0, 0, 1))

                    bmesh.ops.bisect_plane(
                        bm,
                        geom=bm.faces[:] + bm.edges[:] + bm.verts[:],
                        plane_co=plane_co,
                        plane_no=plane_no,
                        clear_inner=False,
                        clear_outer=False,
                    )

            elif mode == "z":
                step = (max_y - min_y) / (cuts + 1)
                for i in range(1, cuts + 1):
                    cut_y = min_y + step * i
                    plane_co = mathutils.Vector((0, cut_y, 0))
                    plane_no = mathutils.Vector((0, 1, 0))

                    bmesh.ops.bisect_plane(
                        bm,
                        geom=bm.faces[:] + bm.edges[:] + bm.verts[:],
                        plane_co=plane_co,
                        plane_no=plane_no,
                        clear_inner=False,
                        clear_outer=False,
                    )

            # Convert the BMesh back to a mesh, counter-transform to local space
            bm.transform(obj.matrix_world.inverted())
            bm.to_mesh(obj.data)
            bm.clear()
            bm.free()
            obj.data.update()

        def cull_boundaries(obj, mode="xy"):
            bpy.ops.object.mode_set(mode='OBJECT')
            obj.select_set(True)
            obj.hide_set(False)
            bpy.ops.object.mode_set(mode='EDIT')

            # Create a BMesh representation
            bm = bmesh.from_edit_mesh(obj.data)
            bm.faces.ensure_lookup_table()

            top_face = None
            bottom_face = None
            max_z = float('-inf')
            min_z = float('inf')

            front_face = None
            back_face = None
            max_y = float('-inf')
            min_y = float('inf')
            
            if mode == "xy":
                for face in bm.faces:
                    face_z = sum([v.co.z for v in face.verts]) / len(face.verts)
                    if face_z > max_z:
                        max_z = face_z
                        top_face = face
                    if face_z < min_z:
                        min_z = face_z
                        bottom_face = face
            elif mode == "z":
                for face in bm.faces:
                    face_y = sum([v.co.y for v in face.verts]) / len(face.verts)
                    if face_y > max_y:
                        max_y = face_y
                        front_face = face
                    if face_y < min_y:
                        min_y = face_y
                        back_face = face

            if mode == "xy":
                if top_face == bottom_face and top_face:
                    bmesh.ops.delete(bm, geom=[top_face], context='FACES')
                elif top_face and bottom_face:
                    bmesh.ops.delete(bm, geom=[top_face, bottom_face], context='FACES')
            elif mode == "z":
                if front_face == back_face and front_face:
                    bmesh.ops.delete(bm, geom=[front_face], context='FACES')
                elif front_face and back_face:
                    bmesh.ops.delete(bm, geom=[front_face, back_face], context='FACES')

            # Update the mesh
            bmesh.update_edit_mesh(obj.data)
            bpy.ops.object.mode_set(mode='OBJECT')

        def get_modified_dimensions(obj):
            # Get the evaluated object which considers modifiers, constraints, etc.
            depsgraph = bpy.context.evaluated_depsgraph_get()  # Get the dependency graph
            evaluated_obj = obj.evaluated_get(depsgraph)  # Get the evaluated version of the object

            # Calculate dimensions from the temporary mesh
            dimensions = obj.dimensions

            # Clean up the temporary mesh data block
            evaluated_obj.to_mesh_clear()

            return mathutils.Vector((dimensions.x, dimensions.y))

        def fill_bbox(obj_phys, obj_bbox):
            bpy.ops.object.mode_set(mode='OBJECT')
            obj_phys.select_set(False)
            obj_phys.hide_set(True)
            obj_bbox.select_set(True)
            bpy.ops.object.mode_set(mode='EDIT')
            bpy.ops.mesh.select_all(action='DESELECT')
            bpy.ops.mesh.select_mode(use_extend=False, use_expand=False, type='EDGE')
            bpy.ops.mesh.select_all(action='SELECT')
            bpy.ops.mesh.edge_face_add()
            bpy.ops.mesh.dissolve_faces()
            bpy.ops.mesh.select_all(action='DESELECT')
            bpy.ops.object.mode_set(mode='OBJECT')
            obj_phys.hide_set(False)

        def pre_clean(obj_phys, obj_bbox):
            bpy.ops.object.mode_set(mode='OBJECT')
            obj_phys.select_set(True)
            obj_phys.hide_set(False)
            obj_bbox.select_set(False)
            obj_bbox.hide_set(True)
            bpy.ops.object.mode_set(mode='EDIT')
            bpy.ops.mesh.reveal()
            bpy.ops.mesh.select_all(action='SELECT')
            bpy.ops.mesh.remove_doubles(threshold=merge_distance)
            bpy.ops.mesh.quads_convert_to_tris(quad_method='BEAUTY', ngon_method='BEAUTY')
            if bpy.context.scene.SrcEngCollProperties.Dissolve:
                bpy.ops.mesh.tris_convert_to_quads(
                    seam=True, sharp=True, materials=True)
                bpy.ops.mesh.dissolve_limited(
                    angle_limit=0.0872665, delimit={'NORMAL'})
            bpy.ops.mesh.decimate(
                ratio=bpy.context.scene.SrcEngCollProperties.Decimate_Ratio)
            bpy.ops.mesh.select_all(action='DESELECT')
            bpy.ops.object.mode_set(mode='OBJECT')
            obj_phys.select_set(False)
            obj_bbox.select_set(True)
            obj_bbox.hide_set(False)

        def solidify_and_bool(obj_phys, obj_bbox, mode="xy"):
            bpy.ops.object.mode_set(mode='OBJECT')
            bpy.ops.object.select_all(action='DESELECT')
            obj_phys.select_set(False)
            obj_bbox.select_set(True)
            bpy.context.view_layer.objects.active = obj_bbox
            solidify_modifier = obj_bbox.modifiers.new(name="BisectSolidify", type='SOLIDIFY')
            solidify_modifier.thickness = obj_bbox.dimensions.z * gap_width
            with bpy.context.temp_override(object=obj_bbox):
                bpy.ops.object.modifier_apply(modifier="BisectSolidify")
            force_convex([obj_bbox])

            bpy.ops.object.mode_set(mode='EDIT')
            bpy.ops.mesh.select_mode(use_extend=False, use_expand=False, type='FACE')
            bpy.ops.mesh.select_all(action='SELECT')
            bpy.ops.mesh.normals_make_consistent(inside=False)
            bpy.ops.object.mode_set(mode='OBJECT')

            bpy.ops.object.origin_set(type='ORIGIN_GEOMETRY', center='MEDIAN')
            if mode == "xy":
                bpy.ops.transform.resize(value=(1.35, 1.35, 1))
            elif mode == "z":
                bpy.ops.transform.resize(value=(1, 1, 1.35))
                
            bpy.ops.object.transform_apply(location=True, rotation=True, scale=True)
            set_origin(obj.location)


            obj_bbox.select_set(False)
            obj_phys.hide_set(False)
            obj_phys.select_set(True)
            bpy.context.view_layer.objects.active = obj_phys

            phys_dimensions = mathutils.Vector((obj_phys.dimensions.x, obj_phys.dimensions.y))
            bool_modifier = obj_phys.modifiers.new(name="BisectBoolean", type='BOOLEAN')
            bool_modifier.object = obj_bbox
            bool_modifier.solver = 'FAST'
            bool_dimensions = get_modified_dimensions(obj_phys)

            # Compare the dimensions with boolean modifier ENABLED, to check if the boolean modifier has unwanted artifacts
            if bool_dimensions != phys_dimensions:
                print("\nSetting boolean solver to EXACT mode due to dimensions warning\n")
                bool_modifier.solver = 'EXACT'

            with bpy.context.temp_override(object=obj_phys):
                bpy.ops.object.modifier_apply(modifier="BisectBoolean")

            # Some cleanup on the boolean'd result
            bpy.ops.object.mode_set(mode='EDIT')
            bpy.ops.mesh.select_mode(use_extend=False, use_expand=False, type='FACE')
            bpy.ops.mesh.select_all(action='SELECT')
            bpy.ops.mesh.hide(unselected=False)
            bpy.ops.mesh.select_mode(use_extend=False, use_expand=False, type='VERT')
            bpy.ops.mesh.select_all(action='SELECT')
            bpy.ops.mesh.split()
            bpy.ops.mesh.delete(type='VERT')
            bpy.ops.mesh.reveal()
            bpy.ops.mesh.normals_make_consistent(inside=False)
            bpy.ops.mesh.select_all(action='DESELECT')
            bpy.ops.object.mode_set(mode='OBJECT')

            bpy.data.objects.remove(obj_bbox)
            total_hull_count = force_convex([obj_phys])
            return total_hull_count

        if len(objs) >= 1:
            for obj in objs:
                obj.select_set(False)

            total_hull_count = 0

            for obj in objs:

                bpy.ops.object.select_all(action='DESELECT')

                root_collection = None
                if 'Collision Models' in bpy.data.collections.keys():
                    root_collection = bpy.data.collections['Collision Models']
                else:
                    root_collection = bpy.data.collections.new("Collision Models")
                    bpy.context.scene.collection.children.link(root_collection)
                original_collection = bpy.context.collection

                obj_collections = [
                    c for c in bpy.data.collections if obj.name in c.objects.keys()]

                obj_phys = None
                collection_phys = None

                bpy.ops.object.mode_set(mode="OBJECT")
                bpy.context.view_layer.objects.active = obj
                obj.select_set(True)

                if (obj.name + "_phys") in bpy.data.objects.keys():
                    bpy.data.objects.remove(bpy.data.objects[obj.name + "_phys"])

                obj_phys, obj_bbox = gen_bisect_setup(obj)

                if slice_mode == 'xy':
                    auto_bisect(obj_bbox, cuts=cuts, mode="xy")
                    cull_edges(obj_bbox, threshold=0.1, mode="xy")
                    fill_bbox(obj_phys, obj_bbox)
                    pre_clean(obj_phys, obj_bbox)
                    cull_boundaries(obj_bbox, mode="xy")
                    total_hull_count += solidify_and_bool(obj_phys, obj_bbox, mode="xy")
                elif slice_mode == 'z':
                    auto_bisect(obj_bbox, cuts=cuts, mode="z")
                    cull_edges(obj_bbox, threshold=0.1, mode="z")
                    fill_bbox(obj_phys, obj_bbox)
                    pre_clean(obj_phys, obj_bbox)
                    cull_boundaries(obj_bbox, mode="z")
                    total_hull_count += solidify_and_bool(obj_phys, obj_bbox, mode="z")

                # Begin finalizing
                bpy.ops.object.shade_smooth()
                obj.hide_set(True)
                bpy.ops.object.transform_apply(location=False, rotation=True, scale=True)
                set_origin(obj.location)

                
                # Setup collection
                if (obj_phys.name.lower()) in bpy.data.collections.keys():
                    collection_phys = bpy.data.collections[obj_phys.name.lower()]
                else:
                    collection_phys = bpy.data.collections.new(obj_phys.name)
                    root_collection.children.link(collection_phys)

                if obj_phys.name not in collection_phys.objects.keys():
                    collection_phys.objects.link(obj_phys)

                # Unlink the new collision model from other collections
                original_collection.objects.unlink(obj_phys)
                for c in obj_collections:
                    if obj_phys.name in c.objects.keys():
                        c.objects.unlink(obj_phys)
                if obj_phys.name in bpy.context.scene.collection.objects.keys():
                    bpy.context.scene.collection.objects.unlink(obj_phys)
                
                # Restore original origin point
                new_origin = tuple(obj.location)
                bpy.context.scene.cursor.location = new_origin
                bpy.ops.object.origin_set(type='ORIGIN_CURSOR', center='MEDIAN')

                # Remove non-manifold and degenerates
                bpy.ops.object.mode_set(mode='EDIT')
                bpy.ops.mesh.select_mode(
                    use_extend=False, use_expand=False, type='VERT')
                bpy.ops.mesh.select_all(action='DESELECT')
                bpy.ops.mesh.select_non_manifold()
                bpy.ops.mesh.select_linked(delimit=set())
                bpy.ops.mesh.delete(type='VERT')
                
                # Cleanup materials
                bpy.ops.object.mode_set(mode='OBJECT')
                obj_phys.data.materials.clear()
                if "phys" not in bpy.data.materials.keys():
                    bpy.data.materials.new("phys")
                obj_phys.data.materials.append(
                    bpy.data.materials["phys"])
                obj_phys.data.materials[0].diffuse_color = (
                    1, 0, 0.78315, 1)
                
                obj_results.append(obj_phys.name)
                obj.select_set(False)

            display_msg_box(
                "Generated collision mesh(es) with total hull count of " + str(total_hull_count) + ".", "Info", "INFO")

        for obj in obj_results:
            bpy.data.objects[obj].select_set(True)

        bpy.context.preferences.edit.use_global_undo = original_undo

        return {'FINISHED'}

# Split Up Collision Mesh operator


class SplitUpSrcCollision(bpy.types.Operator):
    """Splits up a selected collision model into multiple separate objects, with every part adhering to a hull limit based on the Split Increment setting"""
"""
    bl_idname = "object.src_eng_split"
    bl_label = "Split Up Collision Mesh"
    bl_options = {'REGISTER'}

    def execute(self, context):

        objs = check_for_selected()
        if objs == False or get_current_mode() != "OBJECT":
            display_msg_box(
                "At least one mesh object must be selected, in Object Mode.", "Info", "INFO")

            return {'FINISHED'}

        original_undo = bpy.context.preferences.edit.use_global_undo
        bpy.context.preferences.edit.use_global_undo = False
        split_increment = bpy.context.scene.SrcEngCollProperties.Split_Increment

        if len(objs) >= 1:
            total_part_count = 0
            active_obj = bpy.context.active_object
            if active_obj.type != "MESH":
                active_obj = objs[0]
                
            new_selected = list()

            for obj in objs:
                obj.select_set(False)

            for obj in objs:

                bpy.ops.object.select_all(action='DESELECT')

                root_collection = None
                if 'Collision Models' in bpy.data.collections.keys():
                    root_collection = bpy.data.collections['Collision Models']
                else:
                    root_collection = bpy.data.collections.new("Collision Models")
                    bpy.context.scene.collection.children.link(root_collection)

                try:
                    bpy.context.view_layer.objects.active = obj
                except:
                    continue

                obj.select_set(True)
                original_origin = obj.location.copy()

                bpy.ops.object.transform_apply(
                    location=True, rotation=True, scale=True)
                original_name = obj.name
                obj_collections = [
                    c for c in bpy.data.collections if obj.name in c.objects.keys()]
                
                for c in obj_collections:
                    if "_part_" in c.name:
                        display_msg_box(
                            "A selected collision mesh is inside a collection with '_part_' inside the name, indicating it's already split up. Rename the collection so that it ends in '_phys', and try again.", "Error", "ERROR")
                        return {'FINISHED'}
                if "_part_" in obj.name:
                    display_msg_box(
                        "A collision model you're trying to split up already has '_part_' in its name, indicating that it's already been split up.\nRename the mesh object first so its name ends in '_phys' and try again.", "Error", "ERROR")
                    return {'FINISHED'}

                bpy.ops.object.mode_set(mode='OBJECT')
                bpy.ops.object.mode_set(mode='EDIT')

                # Separate all hulls into separate objects
                bpy.ops.mesh.separate(type='LOOSE')
                bpy.ops.object.mode_set(mode='OBJECT')

                # Split up into 32-hull segments
                hulls = bpy.context.selected_objects
                hull_groups = list()

                start = 0
                end = len(hulls)
                step = split_increment

                for i in range(start, end, step):
                    x = i
                    hull_groups.append(hulls[x:x+step])

                bpy.ops.object.select_all(action='DESELECT')

                i = len(hull_groups)-1

                while i >= 0:
                    i = len(hull_groups)-1
                    new_group_collection = None
                    for h in hull_groups[i]:
                        h.select_set(True)

                    bpy.context.view_layer.objects.active = bpy.context.selected_objects[0]
                    bpy.ops.object.duplicate_move(OBJECT_OT_duplicate={"linked": False, "mode": 'TRANSLATION'}, TRANSFORM_OT_translate={"value": (0, 0, 0), "orient_type": 'GLOBAL', "orient_matrix": ((0, 0, 0), (0, 0, 0), (0, 0, 0)), "orient_matrix_type": 'GLOBAL', "constraint_axis": (
                        False, False, False), "mirror": False, "use_proportional_edit": False, "snap": False, "gpencil_strokes": False, "cursor_transform": False, "texture_space": False, "remove_on_cancel": False, "view2d_edge_pan": False, "release_confirm": False, "use_accurate": False, "use_automerge_and_split": False})
                    total_part_count += 1
                    bpy.ops.object.join()
                    new_group_obj = bpy.context.selected_objects[0]

                    bpy.context.view_layer.objects.active = new_group_obj
                    new_group_obj.name = original_name + "_part_" + str(i).zfill(3)

                    # Check if collection for this hull already exists. If not, create it
                    if new_group_obj.name not in bpy.data.collections.keys():
                        new_group_collection = bpy.data.collections.new(
                            new_group_obj.name)
                    else:
                        new_group_collection = bpy.data.collections[new_group_obj.name]

                    if new_group_collection.name not in root_collection.children.keys():
                        root_collection.children.link(new_group_collection)
                    for c in obj_collections:
                        c.objects.unlink(new_group_obj)

                    new_group_collection.objects.link(new_group_obj)
                    if new_group_obj.name in bpy.context.scene.collection.objects.keys():
                        bpy.context.scene.collection.objects.unlink(new_group_obj)
                    bpy.ops.object.transform_apply(
                        location=False, rotation=True, scale=True)
                    
                    # Restore the original object's origin point
                    original_cursor_location = bpy.context.scene.cursor.location.copy()
                    bpy.context.scene.cursor.location = original_origin
                    bpy.ops.object.origin_set(type='ORIGIN_CURSOR', center='MEDIAN')
                    bpy.context.scene.cursor.location = original_cursor_location

                    new_selected.append(new_group_obj)
                    new_group_obj.select_set(False)

                    hull_groups.pop()
                    if len(hull_groups) == 0:
                        break

                # Clean up

                bpy.data.objects.remove(bpy.data.objects[original_name])
                if original_name in bpy.data.collections.keys():
                    bpy.data.collections.remove(
                        bpy.data.collections[original_name])
                for o in hulls:
                    try:
                        if o.name in bpy.data.objects.keys():
                            bpy.data.objects.remove(o)
                    except:
                        continue
            
            for obj in new_selected:
                try:
                    obj.select_set(True)
                except:
                    continue
            try:
                bpy.context.view_layer.objects.active = new_selected[0]
            except:
                bpy.context.view_layer.objects.active = None

        total_part_count = str(total_part_count)
        display_msg_box(
            "Split up collision mesh into " + total_part_count + " part(s).", "Info", "INFO")

        bpy.context.preferences.edit.use_global_undo = original_undo

        return {'FINISHED'}


# Merge Adjacent Similars operator

class Cleanup_MergeAdjacentSimilars(bpy.types.Operator):
    """Merges convex hulls with similar adjacent hulls aggressively, lowering the final amount of hulls & producing a less accurate, but more performant model. If original model was already low-poly to begin with, you probably won't need this"""
    bl_idname = "object.src_eng_cleanup_merge_similars"
    bl_label = "Merge Adjacent Similars"
    bl_options = {'REGISTER'}

    def execute(self, context):
        objs = check_for_selected()
        if objs == False or get_current_mode() != "OBJECT":
            display_msg_box(
                "At least one mesh object must be selected, in Object Mode.", "Info", "INFO")

            return {'FINISHED'}

        original_undo = bpy.context.preferences.edit.use_global_undo
        bpy.context.preferences.edit.use_global_undo = False

        if len(objs) >= 1:
            initial_hull_count = 0
            merged_count = 0
            similarity_threshold = bpy.context.scene.SrcEngCollProperties.Similar_Factor
            active_obj = bpy.context.active_object
            if active_obj.type != "MESH":
                active_obj = objs[0]

            for obj in objs:
                obj.select_set(False)

            for obj in objs:
                bpy.context.scene.cursor.location = obj.location
                bpy.ops.object.select_all(action='DESELECT')

                work_obj = obj
                bpy.context.view_layer.objects.active = obj
                obj.select_set(True)
                
                # Make sure no faces are selected
                bpy.ops.object.mode_set(mode='OBJECT')
                bpy.ops.object.mode_set(mode='EDIT')
                bpy.ops.mesh.reveal()
                bpy.ops.mesh.select_mode(type='FACE')
                bpy.ops.mesh.select_all(action='DESELECT')
                bpy.ops.object.mode_set(mode='OBJECT')
                bpy.ops.object.parent_clear(type='CLEAR_KEEP_TRANSFORM')
                bpy.ops.object.transform_apply(
                    location=True, rotation=True, scale=True)

                # Begin Bmesh processing
                me = work_obj.data
                bm = bmesh.new()
                bm_processed = bmesh.new()

                bm.from_mesh(me)
                bm.verts.index_update()
                bm.verts.ensure_lookup_table()

                hulls = [hull for hull in bmesh_get_hulls(
                    bm, verts=bm.verts)]
                hull_bm_list = list()

                i = 0
                # Create individual hull bmeshes
                for hull in hulls:
                    bm_hull = bmesh.new()

                    # Add vertices to individual bmesh hull
                    for vert in hull:
                        bmesh.ops.create_vert(bm_hull, co=vert.co)
                    bm_hull.verts.index_update()
                    bm_hull.verts.ensure_lookup_table()

                    # Generate convex hull
                    ch = bmesh.ops.convex_hull(
                        bm_hull, input=bm_hull.verts, use_existing_faces=False)

                    bmesh.ops.delete(
                        bm_hull,
                        geom=list(set(ch["geom_unused"] + ch["geom_interior"])),
                        context='FACES')

                    bmesh.ops.recalc_face_normals(bm_hull, faces=bm_hull.faces)

                    # Prepare for processing
                    bm_hull.verts.index_update()
                    bm_hull.edges.index_update()
                    bm_hull.faces.index_update()
                    bm_hull.verts.ensure_lookup_table()
                    bm_hull.edges.ensure_lookup_table()
                    bm_hull.faces.ensure_lookup_table()
                    bm_hull.transform(work_obj.matrix_world)

                    # Add to bm list as a 4-element tuple - index, bm, volume, and face count
                    hull_bm_list.append((i, bm_hull, bm_hull.calc_volume(
                        signed=False), len(bm_hull.faces)))
                    initial_hull_count += 1
                    i += 1

                if initial_hull_count == 1:
                    display_msg_box(
                        "There is only one hull remaining in this collision mesh. Aborting...", "Info", "INFO")
                    return {'FINISHED'}

                i = 0
                # Compare hulls
                for index1, bm1, vol1, facecount1 in hull_bm_list:
                    if index1 == None:
                        continue

                    for index2, bm2, vol2, facecount2 in hull_bm_list:

                        if index2 == index1:
                            continue
                        if index2 == None or index1 == None:
                            continue

                        # Compare volumes
                        if vol2 >= (vol1 * similarity_threshold) and vol2 <= (vol1 * (1+(1-similarity_threshold))):

                            # Compare face counts
                            if facecount2 >= (facecount1 * similarity_threshold) and facecount2 <= (facecount1 * (1+(1-similarity_threshold))):

                                # Get center coordinate of both hulls
                                bm1_origin_x = (
                                    sum(v.co[0] for v in bm2.verts)) / len(bm2.verts)
                                bm1_origin_y = (sum(v.co[0]
                                                for v in bm2.verts)) / 3
                                bm1_origin_z = (sum(v.co[0]
                                                for v in bm2.verts)) / 3
                                bm1_origin = mathutils.Vector((bm1_origin_x, bm1_origin_y, bm1_origin_z))

                                bm2_origin_x = (
                                    sum(v.co[0] for v in bm2.verts)) / len(bm2.verts)
                                bm2_origin_y = (sum(v.co[0]
                                                for v in bm2.verts)) / 3
                                bm2_origin_z = (sum(v.co[0]
                                                for v in bm2.verts)) / 3
                                bm2_origin = mathutils.Vector((
                                    bm2_origin_x, bm2_origin_y, bm2_origin_z))

                                # # Get distance between the two center coordinates
                                distance = (bm1_origin - bm2_origin).length

                                # Check if hulls are close together
                                if distance < ((vol1 ** (1/3)) * 2.5):

                                    # Check if any verts overlap
                                    bm1_verts = [list(v.co) for v in bm1.verts]
                                    bm2_verts = [list(v.co) for v in bm2.verts]

                                    for v in bm1_verts:
                                        v[0] = round(v[0], 2)
                                        v[1] = round(v[1], 2)
                                        v[2] = round(v[2], 2)
                                    for v in bm2_verts:
                                        v[0] = round(v[0], 2)
                                        v[1] = round(v[1], 2)
                                        v[2] = round(v[2], 2)
                                    overlap = [
                                        v for v in bm1_verts if v in bm2_verts]

                                    # If any verts overlapped, then the hulls are adjacent!
                                    if len(overlap) > 0:

                                        print("Merging hull " + str(index1) +
                                            " with hull " + str(index2))

                                        new_combined_bm = bmesh.new()
                                        new_verts = [
                                            v for v in bm1.verts] + [v for v in bm2.verts]
                                        for v in new_verts:
                                            bmesh.ops.create_vert(
                                                new_combined_bm, co=v.co)
                                        new_combined_bm.verts.index_update()
                                        new_combined_bm.verts.ensure_lookup_table()

                                        hull_bm_list[index1] = tuple((
                                            None, None, None, None))
                                        bm1.clear()
                                        bm1.free()
                                        hull_bm_list[index2] = tuple((
                                            None, None, None, None))
                                        bm2.clear()
                                        bm2.free()

                                        # Generate convex hull
                                        ch = bmesh.ops.convex_hull(
                                            new_combined_bm, input=new_combined_bm.verts, use_existing_faces=False)

                                        junk_geometry = list(
                                            set(ch["geom_unused"] + ch["geom_interior"]))
                                        bmesh.ops.delete(
                                            new_combined_bm, geom=junk_geometry, context='VERTS')

                                        # Join the hull with the main hull containing all of them
                                        bmesh_join(bm_processed, new_combined_bm)
                                        new_combined_bm.clear()
                                        new_combined_bm.free()
                                        break

                # Get quick count of how many hulls were merged
                merged_count = len([h[0] for h in hull_bm_list if h[0] == None])

                # Re-add hulls that were never merged
                unmerged_hulls = [
                    bm_unmerged[1] for bm_unmerged in hull_bm_list if None not in bm_unmerged]

                for unmerged_hull in unmerged_hulls:
                    bmesh_join(bm_processed, unmerged_hull)
                    unmerged_hull.clear()
                    unmerged_hull.free()

                # Finally update mesh
                bm_processed.to_mesh(me)
                me.update()
                bm.clear()
                bm.free()
                bm_processed.clear()
                bm_processed.free()

                # End Bmesh processing

                # Cleanup mesh
                bpy.ops.object.mode_set(mode='OBJECT')
                bpy.ops.object.mode_set(mode='EDIT')
                bpy.ops.mesh.select_all(action='DESELECT')
                bpy.ops.mesh.select_mode(
                    use_extend=False, use_expand=False, type='VERT')
                bpy.ops.mesh.select_all(action='DESELECT')
                bpy.ops.object.mode_set(mode='OBJECT')
                bpy.ops.object.shade_smooth()

                # Reset dimensions and apply final transforms
                bpy.ops.object.transform_apply(
                    location=True, rotation=True, scale=True)
                set_origin(bpy.context.scene.cursor.location)
            
            for obj in objs:
                obj.select_set(True)
            bpy.context.view_layer.objects.active = active_obj

            display_msg_box(
                "Processed original " + str(initial_hull_count) + " hull(s).\nMerged " + str(merged_count) + " total hull(s).", "Info", "INFO")

        bpy.context.preferences.edit.use_global_undo = original_undo

        return {'FINISHED'}

# Remove Thin Hulls operator

class Cleanup_RemoveThinHulls(bpy.types.Operator):
    """Removes thin hulls, based on the Thin Threshold setting"""
    bl_idname = "object.src_eng_cleanup_remove_thin_hulls"
    bl_label = "Remove Thin Hulls"
    bl_options = {'REGISTER'}

    def execute(self, context):
        objs = check_for_selected()
        if objs == False or get_current_mode() != "OBJECT":
            display_msg_box(
                "At least one mesh object must be selected, in Object Mode.", "Info", "INFO")

            return {'FINISHED'}

        original_undo = bpy.context.preferences.edit.use_global_undo
        bpy.context.preferences.edit.use_global_undo = False

        if len(objs) >= 1:
            amount_removed = 0
            thin_threshold = bpy.context.scene.SrcEngCollProperties.Thin_Threshold
            active_obj = bpy.context.active_object
            if active_obj.type != "MESH":
                active_obj = objs[0]

            for obj in objs:
                obj.select_set(False)

            for obj in objs:
                bpy.ops.object.select_all(action='DESELECT')

                bpy.context.view_layer.objects.active = obj
                obj.select_set(True)

                amount_removed += select_thin_hulls(obj, thin_threshold)
                if amount_removed > 0:
                    bpy.ops.object.mode_set(mode='EDIT')
                    bpy.ops.mesh.delete(type='FACE')
                    bpy.ops.object.mode_set(mode='OBJECT')

                    # Cleanup
                    bpy.ops.object.transform_apply(
                        location=False, rotation=True, scale=True)

            for obj in objs:
                obj.select_set(True)
            bpy.context.view_layer.objects.active = active_obj
        
            display_msg_box(
                "Removed " + str(amount_removed) + " thin hull(s).", "Info", "INFO")
        bpy.context.preferences.edit.use_global_undo = original_undo

        return {'FINISHED'}


# Merge Thin Hulls operator

class Cleanup_MergeThinHulls(bpy.types.Operator):
    """Merges thin hulls with adjacent hulls (if any), based on the Thin Threshold setting"""
    bl_idname = "object.src_eng_cleanup_merge_thin_hulls"
    bl_label = "Merge Thin Hulls"
    bl_options = {'REGISTER'}

    def execute(self, context):
        objs = check_for_selected()
        if objs == False or get_current_mode() != "OBJECT":
            display_msg_box(
                "At least one mesh object must be selected, in Object Mode.", "Info", "INFO")

            return {'FINISHED'}

        original_undo = bpy.context.preferences.edit.use_global_undo
        bpy.context.preferences.edit.use_global_undo = False

        if len(objs) >= 1:
            amount_merged = 0
            thin_threshold = bpy.context.scene.SrcEngCollProperties.Thin_Threshold

            active_obj = bpy.context.active_object
            if active_obj.type != "MESH":
                active_obj = objs[0]

            for obj in objs:
                obj.select_set(False)

            for obj in objs:
                bpy.ops.object.select_all(action='DESELECT')

                bpy.context.view_layer.objects.active = obj
                obj.select_set(True)

                amount_merged += select_thin_hulls(obj, thin_threshold)
                if amount_merged > 0:
                    bpy.ops.object.mode_set(mode='EDIT')
                    bpy.ops.mesh.remove_doubles(threshold=0.0001, use_unselected=True)
                    bpy.ops.object.mode_set(mode='OBJECT')
                    force_convex([obj])

                    # Cleanup
                    bpy.ops.object.transform_apply(
                        location=False, rotation=True, scale=True)

            for obj in objs:
                obj.select_set(True)
            bpy.context.view_layer.objects.active = active_obj
        
            display_msg_box(
                "Merged " + str(amount_merged) + " thin hull(s) with adjacent hulls (if any).", "Info", "INFO")
        bpy.context.preferences.edit.use_global_undo = original_undo

        return {'FINISHED'}


# Find Thin Hulls operator

class Cleanup_FindThinHulls(bpy.types.Operator):
    """Finds thin hulls, based on the Thin Threshold setting. The hulls are highlighted in Edit Mode, without any modification"""
    bl_idname = "object.src_eng_cleanup_find_thin_hulls"
    bl_label = "Find Thin Hulls"
    bl_options = {'REGISTER'}

    def execute(self, context):
        objs = check_for_selected()
        if objs == False or get_current_mode() != "OBJECT":
            display_msg_box(
                "At least one mesh object must be selected, in Object Mode.", "Info", "INFO")

            return {'FINISHED'}

        original_undo = bpy.context.preferences.edit.use_global_undo
        bpy.context.preferences.edit.use_global_undo = False

        if len(objs) >= 1:
            amount_selected = 0
            thin_threshold = bpy.context.scene.SrcEngCollProperties.Thin_Threshold

            active_obj = bpy.context.active_object
            if active_obj.type != "MESH":
                active_obj = objs[0]

            for obj in objs:
                obj.select_set(False)

            for obj in objs:
                bpy.ops.object.select_all(action='DESELECT')

                bpy.context.view_layer.objects.active = obj
                obj.select_set(True)

                amount_selected += select_thin_hulls(obj, thin_threshold)
                
            for obj in objs:
                obj.select_set(True)

            if amount_selected > 0:
                bpy.ops.object.mode_set(mode='EDIT')
            bpy.context.view_layer.objects.active = active_obj
        
            display_msg_box(
                "Selected " + str(amount_selected) + " thin hull(s).", "Info", "INFO")
        bpy.context.preferences.edit.use_global_undo = original_undo

        return {'FINISHED'}


# Force Convex operator


class Cleanup_ForceConvex(bpy.types.Operator):
    """Forces all existing hulls in the selected object to be convex. Warning: This operator will remove any non-manifold geometry, along with UV maps and vertex colors"""
    bl_idname = "object.src_eng_cleanup_force_convex"
    bl_label = "Force Convex"
    bl_options = {'REGISTER'}

    def execute(self, context):
        objs = check_for_selected()
        if objs == False or get_current_mode() != "OBJECT":
            display_msg_box(
                "At least one mesh object must be selected, in Object Mode.", "Info", "INFO")

            return {'FINISHED'}
        
        active_obj = bpy.context.active_object
        if active_obj.type != "MESH":
            active_obj = objs[0]

        total_hull_count = force_convex(objs)
        for obj in objs:
            obj.select_set(True)
        bpy.context.view_layer.objects.active = active_obj

        display_msg_box(
            "Processed " + str(total_hull_count) + " hulls.", "Info", "INFO")

        return {'FINISHED'}
    

class Cleanup_CountHulls(bpy.types.Operator):
    """Counts all loose mesh islands in the selected object(s) and prints out the result, without modifying the mesh(es). Note that this will work on non-collision meshes too"""
    bl_idname = "object.src_eng_cleanup_count_hulls"
    bl_label = "Count Hulls"
    bl_options = {'REGISTER'}

    def execute(self, context):
        objs = check_for_selected()
        if objs == False or get_current_mode() != "OBJECT":
            display_msg_box(
                "At least one mesh object must be selected, in Object Mode.", "Info", "INFO")

            return {'FINISHED'}
        
        if len(objs) >= 1:
            total_hull_count = 0
            
            for obj in objs:
                total_hull_count += count_loose_geometry(obj)
            
        display_msg_box(
            "Counted " + str(total_hull_count) + " hull(s).", "Info", "INFO")

        return {'FINISHED'}

# Remove Inside Hulls operator

class Cleanup_RemoveInsideHulls(bpy.types.Operator):
    """Removes hulls that are (entirely or mostly) inside other hulls"""
    bl_idname = "object.src_eng_cleanup_remove_inside"
    bl_label = "Remove Inside Hulls"
    bl_options = {'REGISTER'}

    def execute(self, context):
        objs = check_for_selected()
        if objs == False or get_current_mode() != "OBJECT":
            display_msg_box(
                "At least one valid mesh object must be selected, in Object Mode.", "Info", "INFO")

            return {'FINISHED'}

        original_undo = bpy.context.preferences.edit.use_global_undo
        bpy.context.preferences.edit.use_global_undo = False

        if len(objs) >= 1:
            active_obj = bpy.context.active_object
            if active_obj.type != "MESH":
                active_obj = objs[0]
            
            for obj in objs:
                obj.select_set(False)

            amount_to_remove = 0

            for obj in objs:

                bpy.ops.object.select_all(action='DESELECT')

                bpy.context.view_layer.objects.active = obj
                obj.select_set(True)

                original_name = obj.name
                original_origin = obj.location.copy()

                # Make sure no faces are selected
                bpy.ops.object.mode_set(mode='OBJECT')
                bpy.ops.object.mode_set(mode='EDIT')
                bpy.ops.mesh.reveal()
                bpy.ops.mesh.select_mode(type='VERT')
                bpy.ops.mesh.select_all(action='DESELECT')
                bpy.ops.object.mode_set(mode='OBJECT')

                # Select all hulls and separate them into separate objects
                bpy.ops.object.mode_set(mode='EDIT')
                bpy.ops.mesh.select_all(action='SELECT')
                bpy.ops.mesh.separate(type='LOOSE')
                bpy.ops.object.mode_set(mode='OBJECT')
                bpy.ops.object.origin_set(
                    type='ORIGIN_GEOMETRY', center='MEDIAN')

                hulls = [o for o in bpy.context.selected_objects]
                hulls_to_delete = set()

                for outer_hull in hulls:

                    # Get bounding box lowest and highest vertices - to check if inner hull is inside it later
                    hull_bbox_min = outer_hull.matrix_world @ mathutils.Vector(
                        outer_hull.bound_box[0])
                    hull_bbox_max = outer_hull.matrix_world @ mathutils.Vector(
                        outer_hull.bound_box[6])

                    def check_inside_bbox(h):
                        loc = h.location
                        if hull_bbox_min[0] < loc[0] and hull_bbox_max[0] > loc[0]:
                            if hull_bbox_min[1] < loc[1] and hull_bbox_max[1] > loc[1]:
                                if hull_bbox_min[2] < loc[2] and hull_bbox_max[2] > loc[2]:
                                    return True
                        else:
                            return False

                    # Create list of hulls that are smalller than this hull and within the outer hull's bounding box
                    hulls_to_check = [h for h in hulls if h != outer_hull and h.dimensions <
                                    outer_hull.dimensions and check_inside_bbox(h)]

                    for inner_hull in hulls_to_check:
                        inner_hull_loc = inner_hull.location
                        outer_hull_faces = outer_hull.data.polygons

                        # This returns a list of frontface indices. Backfaces are not included
                        frontfaces = [f.index for f in outer_hull_faces if f.normal.dot(
                            inner_hull_loc - (outer_hull.matrix_world @ f.center)) > 0]

                        # Zero length means no frontfaces were visible - aka inner hull truly is inside outer hull
                        if len(frontfaces) == 0:

                            # Mark the hull for deletion if it's inside another hull
                            hulls_to_delete.add(inner_hull)
                        else:
                            continue

                bpy.ops.object.mode_set(mode='OBJECT')

                amount_to_remove += len(hulls_to_delete)

                # Remove marked hulls
                for h in hulls_to_delete:
                    bpy.data.objects.remove(h)

                # Rejoin and clean up
                bpy.context.view_layer.objects.active = bpy.context.selected_objects[0]
                if len([o for o in bpy.context.selected_objects if o.hide_get() == False]) > 1:
                    bpy.ops.object.join()

                bpy.context.active_object.name = original_name
                bpy.ops.object.transform_apply(
                    location=False, rotation=True, scale=True)
                bpy.ops.object.shade_smooth()

                # Restore the original object's origin point
                original_cursor_location = bpy.context.scene.cursor.location.copy()
                bpy.context.scene.cursor.location = original_origin.copy()
                bpy.ops.object.origin_set(type='ORIGIN_CURSOR', center='MEDIAN')
                bpy.context.scene.cursor.location = original_cursor_location

            for obj in objs:
                obj.select_set(True)
            bpy.context.view_layer.objects.active = active_obj

            display_msg_box(
                "Removed " + str(amount_to_remove) + " hull(s).", "Info", "INFO")

        bpy.context.preferences.edit.use_global_undo = original_undo

        return {'FINISHED'}

# Generate Source Engine QC


class GenerateSourceQC(bpy.types.Operator):
    """Generate QC files for all collision meshes stored in the Collision Models collection in your Blender file. These QC files can be used to compile the models for Source Engine"""
    bl_idname = "object.src_eng_qc"
    bl_label = "Generate Source Engine QC"
    bl_options = {'REGISTER'}

    def execute(self, context):
        
        surfaceprop = bpy.context.scene.SrcEngCollProperties.QC_SurfaceProp
        QC_folder = bpy.path.abspath(
            bpy.context.scene.SrcEngCollProperties.QC_Folder)
        models_dir = bpy.context.scene.SrcEngCollProperties.QC_Src_Models_Dir
        mats_dir = bpy.context.scene.SrcEngCollProperties.QC_Src_Mats_Dir
        dirs = [bpy.context.scene.SrcEngCollProperties.QC_Folder,
                models_dir, mats_dir]

        # Check for trailing slashes
        for dir in dirs:
            if not dir.endswith("\\") and not dir.endswith("/"):
                display_msg_box(
                    "One of your specified QC directories is missing a trailing slash (\\ or /) at the end.\nAdd one first and then try again", "Error", "ERROR")
                return {'FINISHED'}

        # Get the Collision Models collection
        root_collection = None
        if 'Collision Models' in bpy.data.collections.keys():
            if len(bpy.data.collections["Collision Models"].all_objects) > 0:
                root_collection = bpy.data.collections['Collision Models']
            else:
                display_msg_box(
                    "There are no collision models in the 'Collision Models' collection. Place your collision models there first", "Error", "ERROR")
                
        else:
            display_msg_box(
                "There is no 'Collision Models' collection. Please create one with that exact name, and then place your collision models inside it", "Error", "ERROR")
        if root_collection == None:
            return {'FINISHED'}

        # Get list of all objects in the Collision Models collection, but exclude any that are hidden
        objs = [obj for obj in root_collection.all_objects if not obj.hide_get()]
        if len(objs) == 0:
            display_msg_box(
            "There are no visible collision models in the Collision Models collection. Check to make sure that they're not all hidden.", "Error", "ERROR")
            return {'FINISHED'}

        # Generate QC file for every object
        for obj in objs:
            with open(f"{QC_folder}{obj.name}.qc", 'w') as qc_file:
                qc_file.writelines(generate_QC_lines(
                    obj, models_dir, mats_dir, surfaceprop))

        # Generate empty placeholder SMD
        with open(QC_folder + "Empty.smd", 'w') as empty_smd_file:
            empty_smd_file.writelines(generate_SMD_lines())

        # Generate the transparent physics VTF/VMT
        shutil.copy(addon_path + "/phys.vmt", QC_folder + "/phys.vmt")

        display_msg_box("QC files generated successfully in " + QC_folder +
                        "\n\nYou will still need to export your collision models as SMD through other means (ie. Blender Source Tools or SourceOps)", "Info", "INFO")

        return {'FINISHED'}
    
# Copy QC Overrides to Selected

class CopyQCOverrides(bpy.types.Operator):
    """Copy the QC overrides from the current active object (added as string-type Custom Properties) to all other selected objects"""
    bl_idname = "object.copy_qc_overrides"
    bl_label = "Copy QC Overrides"
    bl_options = {'REGISTER'}

    def execute(self, context):
        
        objs = check_for_selected()
        if objs == False or get_current_mode() != "OBJECT":
            display_msg_box(
                "At least one mesh object must be selected, in Object Mode.", "Info", "INFO")

            return {'FINISHED'}
        
        active_obj = bpy.context.active_object
        if active_obj.type != "MESH":
            active_obj = objs[0]

        qc_overrides_keys, qc_overrides_values = list(), list()

        if len(objs) >= 2:
            qc_overrides_keys = [prop for prop in active_obj.keys() if not prop.startswith("_RNA_UI") and prop[0] == "$"]
            qc_overrides_values = [active_obj[prop] for prop in active_obj.keys() if not prop.startswith("_RNA_UI") and prop[0] == "$"]

        qc_overrides = {qc_overrides_keys[i]: qc_overrides_values[i] for i in range(len(qc_overrides_keys))}

        for obj in objs:
            for override in qc_overrides.keys():
                bpy.data.objects[obj.name][override] = qc_overrides[override]

        display_msg_box(f"{str(len(qc_overrides.keys()))} override(s) copied to {len(objs)-1} objects.", "Info", "INFO")

        return {'FINISHED'}
    
# Clear QC Overrides from Selected

class ClearQCOverrides(bpy.types.Operator):
    """Clear the QC overrides from all selected objects"""
    bl_idname = "object.clear_qc_overrides"
    bl_label = "Clear QC Overrides"
    bl_options = {'REGISTER'}

    def execute(self, context):
        
        objs = check_for_selected()
        if objs == False or get_current_mode() != "OBJECT":
            display_msg_box(
                "At least one mesh object must be selected, in Object Mode.", "Info", "INFO")

            return {'FINISHED'}

        num_deleted = 0
        for obj in objs:

            qc_overrides_keys = [prop for prop in obj.keys() if not prop.startswith("_RNA_UI") and prop[0] == "$"]

            for obj in objs:
                for override in qc_overrides_keys:
                    del obj[override]
                    num_deleted += 1

        display_msg_box(f"{str(num_deleted)} override(s) deleted from {len(objs)} object(s).", "Info", "INFO")

        return {'FINISHED'}

# Recommended Settings button

class RecommendedCollSettings(bpy.types.Operator):
    """Automatically modify the settings below based on the current active mesh object (ignoring any other selected objects). Note: This is not foolproof. You may still need to tweak the settings yourself"""
    bl_idname = "object.src_eng_recc_settings"
    bl_label = "Recommended Settings"
    bl_options = {'REGISTER'}

    def execute(self, context):

        if check_for_selected():

            obj = bpy.context.active_object
            if obj.type == 'MESH':
                if len(obj.data.polygons) == 0:
                    return {'FINISHED'}
            else:
                    return {'FINISHED'}

            avg_dimensions = 0
            for d in list(obj.dimensions):
                avg_dimensions += d
            avg_dimensions = avg_dimensions / 3

            avg_length = get_avg_length(obj)
            extrude_modifier = avg_length * 0.07
            gap_width = avg_dimensions / 106.77
            voxel_res = avg_dimensions / 42.708

            bpy.context.scene.SrcEngCollProperties.Extrusion_Modifier = extrude_modifier
            bpy.context.scene.SrcEngCollProperties.Gap_Width = gap_width
            bpy.context.scene.SrcEngCollProperties.Voxel_Resolution = voxel_res
            print("Recommended Settings:")
            print("- Extrusion Modifier: " + str(extrude_modifier))
            print("- Voxel Resolution: " + str(voxel_res))
            print("- Gap Width: " + str(gap_width))

        return {'FINISHED'}

# Update VMF operator

class UpdateVMF(bpy.types.Operator):
    """Automatically adds any split-up (ie. mymodel_part_000.mdl) collision models in the 'Collision Models' collection to the VMF, if they aren't already contained in it. IMPORTANT: The first part, '_part_000.mdl' must be added manually to VMF"""
    bl_idname = "object.src_eng_vmf_update"
    bl_label = "Update VMF"
    bl_options = {'REGISTER'}

    def execute(self, context):

        VMF_path = bpy.path.abspath(
            bpy.context.scene.SrcEngCollProperties.VMF_File)
        remove_on = bpy.context.scene.SrcEngCollProperties.VMF_Remove

        # Get the Collision Models collection
        root_collection = None
        if 'Collision Models' in bpy.data.collections.keys():
            if len(bpy.data.collections["Collision Models"].all_objects) > 0:
                root_collection = bpy.data.collections['Collision Models']
            else:
                display_msg_box(
                    "There are no collision models in the 'Collision Models' collection. Place your collision models there first", "Error", "ERROR")
        else:
            display_msg_box(
                "There is no 'Collision Models' collection. Please create one with that exact name, and then place your collision models inside it", "Error", "ERROR")
        if root_collection == None:
            return {'FINISHED'}

        # Get list of all objects in the Collision Models collection
        objs = [
            obj.name for obj in root_collection.all_objects if "_part_" in obj.name]
        
        # Rename all collision pieces to lowercase to match Hammer's forced lower-casing
        for o in objs:
            bpy.data.objects[o].name = o.lower()
            o = o.lower()

        print(f"List of collision objs: {objs}")
        objs.sort()

        print("Opening VMF file at: " + VMF_path)
        # Open VMF file for reading and parse data
        with open(VMF_path, 'r+') as vmf_file:

            total_length = len(vmf_file.readlines())

            print(str(total_length) + " lines loaded from VMF file.")
            vmf_file.seek(0)

            contents = vmf_file.read()

            # Make sure it's a real VMF file first
            if "versioninfo" not in contents[0:30]:
                display_msg_box(
                    "Please select a valid VMF file and try again", "Error", "ERROR")
                return {'FINISHED'}

            # Setup Regex
            entities_regex = r'^[a-z_]+\n\{\n(?:.*?)^(?:\})\n'
            part_zero_regex = r'(?!:/)[a-z_]*(?:_part_000)'
            id_regex = r'\t\"id\" \"\d+\"'

            # Parse VMF for entities
            entities = re.findall(
                entities_regex, contents, re.IGNORECASE | re.MULTILINE | re.DOTALL)
            print(str(len(entities)) +
                    " entities were found in the VMF.")

            # If removal mode is enabled, remove entities containing _part_
            if remove_on:
                new_entity_list = entities
                removed_count = 0
                for ent in entities:
                    if "_part_" in ent:
                        removed_count += 1
                        print("REMOVING ENTITY:\n\n")
                        print(ent)
                        print("\n\n")
                        new_entity_list.remove(ent)
                if removed_count > 0:
                    vmf_file.close()
                    with open(VMF_path, 'w') as vmf_file:
                        vmf_file.writelines(new_entity_list)
                        vmf_file.write("\n")
                        display_msg_box(
                            "VMF file modified successfully\n"+f"Removed {str(removed_count)} entities from the VMF.", "Info", "INFO")
                else:
                    display_msg_box(
                        "No partitioned collision models were found in the VMF file.", "Info", "INFO")
                vmf_file.close()
                return {'FINISHED'}

            parts_zero_found = list()
            i = 0

            # Scan entity list for needed data
            for ent in entities:

                # Look for any _part_0.mdl
                part_zero_found = re.search(part_zero_regex, ent, re.IGNORECASE |
                                            re.MULTILINE | re.DOTALL)
                if part_zero_found:
                    parts_zero_found.append(
                        (i, part_zero_found.group()))
                    print("Found part zero")

                i += 1


            print(f"{len(parts_zero_found)} parts zero found")

            new_entities_to_add = set()

            # For every _part_000 that was found...
            for part in parts_zero_found:
                
                print(f"Processing part: {part}")
                root = part[1][0:-3]
                print(f"Root: {root}")
                entity_index = part[0]

                matching_objs = set([o.lower() for o in objs if root.lower() in o.lower()])
                print(f"Length of matching_objs: {len(matching_objs)}")

                # For every matched Blender object
                for matched in matching_objs:

                    # Check if the matched object exists in the VMF already
                    if matched not in contents:

                        old_entity = str(entities[entity_index])

                        # Add new part number
                        new_entity = old_entity.replace(
                            "_part_000", "_part_" + matched[-3:])

                        # Make sure collision is enabled in the new entity, just in case
                        new_entity = new_entity.replace(
                            '"solid" "0"', '"solid" "1"')

                        # Remove old entity ID. Hammer will automatically assign a new one
                        old_id = re.search(id_regex, new_entity, re.IGNORECASE |
                                            re.MULTILINE | re.DOTALL)
                        old_id = old_id.group()
                        new_entity = new_entity.replace(old_id, "")

                        new_entities_to_add.add(new_entity)
                    else:
                        continue

            new_entities_to_add = list(new_entities_to_add)
            new_entities_to_add.sort()
            if len(new_entities_to_add) > 0:
                # Write new entities
                vmf_file.seek(0, 2)
                vmf_file.write("\n")
                vmf_file.writelines(new_entities_to_add)
                vmf_file.write("\n")
                vmf_file.close()
                display_msg_box(
                    "VMF file modified successfully\n"+f"Added {str(len(new_entities_to_add))} new entities to VMF.", "Info", "INFO")
            else:
                display_msg_box(
                    "VMF is already up-to-date", "Info", "INFO")

        return {'FINISHED'}


# Update VMF operator

class ExportVMF(bpy.types.Operator):
    """Converts all selected collision mesh objects into Hammer brushes and exports them as a single VMF file"""
    bl_idname = "object.src_eng_vmf_export"
    bl_label = "Export VMF"
    bl_options = {'REGISTER'}

    def execute(self, context):
        vmf_export_dir = bpy.context.scene.SrcEngCollProperties.VMF_Export_Dir
        if vmf_export_dir == "" or vmf_export_dir == "//":
            display_msg_box(
                f"ERROR: You need to choose an export folder above first. Choose one and then try again.", "Error", "ERROR")
            return {'FINISHED'}
        
        objs = check_for_selected()
        if objs == False or get_current_mode() != "OBJECT":
            display_msg_box(
                "At least one mesh object must be selected, in Object Mode.", "Info", "INFO")

            return {'FINISHED'}

        if len(objs) >= 1:
            obj_index = 0
            total_hull_count = 0
            total_solids_count = 0
            vmf_texture = bpy.context.scene.SrcEngCollProperties.VMF_Texture

            for obj in objs:
                obj.select_set(False)

            for obj in objs:
                bpy.ops.object.select_all(action='DESELECT')

                # Prep the meshes first
                bpy.context.view_layer.objects.active = obj
                obj.select_set(True)
                obj_phys = None

                bpy.ops.object.mode_set(mode="OBJECT")
                bpy.ops.object.duplicate(linked=False)

                obj_phys = bpy.context.active_object
                mesh = obj_phys.data

                # Snap vertices to grid scale of 1
                for vert in mesh.vertices:
                    vert.co.x = round(vert.co.x)
                    vert.co.y = round(vert.co.y)
                    vert.co.z = round(vert.co.z)

                # Update the mesh
                mesh.update()

                force_convex([obj])

                # Begin Bmesh processing
                bm = bmesh.new()
                bm.from_mesh(obj_phys.data)
                bm.faces.ensure_lookup_table()

                # Tag all faces as unvisited
                for face in bm.faces:
                    face.tag = False

                islands = []


                for face in bm.faces:
                    # Skip already visited faces
                    if face.tag:
                        continue

                    # New island
                    island = []
                    faces_to_visit = [face]

                    while faces_to_visit:
                        current_face = faces_to_visit.pop()
                        current_face.tag = True

                        # Process triangle faces
                        if len(current_face.verts) == 3:
                            vertices = [current_face.verts[i].co.copy() for i in range(3)]
                            island.append(vertices)

                        # Visit adjacent faces
                        for edge in current_face.edges:
                            for linked_face in edge.link_faces:
                                if not linked_face.tag:
                                    faces_to_visit.append(linked_face)

                    islands.append(island)
                    total_hull_count += 1

                bm.free()
                bpy.data.objects.remove(obj_phys)
                obj.select_set(True)
                bpy.context.view_layer.objects.active = obj

                # VMF Setup
                vmf = new_vmf()
                solids_to_add = []
                print(f"\n\n[VMF Export] Total island count: {len(islands)}")

                for island in islands:

                    sides_to_add = []

                    print(f"[VMF Export] Total triangle count in island: {len(island)}")

                    for triangle in island:
                        new_side = Side()

                        # A Hammer brush's "side" is basically the equivalent of a Blender triangle
                        new_side.plane[0].x, new_side.plane[0].z, new_side.plane[0].y = int(round(triangle[0][0],0)), int(round(triangle[0][1],0)) * -1, int(round(triangle[0][2],0))
                        new_side.plane[1].x, new_side.plane[1].z, new_side.plane[1].y = int(round(triangle[1][0],0)), int(round(triangle[1][1],0)) * -1, int(round(triangle[1][2],0))
                        new_side.plane[2].x, new_side.plane[2].z, new_side.plane[2].y = int(round(triangle[2][0],0)), int(round(triangle[2][1],0)) * -1, int(round(triangle[2][2],0))
                        new_side.plane[0], new_side.plane[2] = new_side.plane[2], new_side.plane[0]
                        sides_to_add.append(new_side)

                    print(f"[VMF Export] Total side count: {len(sides_to_add)}")
                    print(f"[VMF Export] VMF Texture to set: {vmf_texture}")

                    new_solid = Solid()

                    print(f"[VMF Export] Texture now set: {new_solid.has_texture('tools/toolsnodraw')}")

                    for side in sides_to_add:
                        new_solid.add_sides(side)

                    new_solid.set_texture(vmf_texture)
                    solids_to_add.append(new_solid)

                    print(f"[VMF Export] Added {len(sides_to_add)} sides to solid")
                
                for solid in solids_to_add:
                    vmf.add_solids(solid)
                print(f"[VMF Export] Added {len(solids_to_add)} solids to VMF")

                total_solids_count += len(solids_to_add)

                import time
                export_path = os.path.join(bpy.path.abspath(vmf_export_dir), time.strftime("%Y%m%d-%H%M%S")) + "" + f" {str(obj_index)}.vmf"
                print("Export path: " + export_path)

                obj_index += 1
                
                try:
                    vmf.export(export_path)
                except Exception as e:
                    display_msg_box(
                        f"Couldn't write VMF due to following:\n{e}", "Info", "INFO")

                    return {'FINISHED'}

            display_msg_box(
                f"{total_solids_count} solids exported successfully to VMF folder:\n{vmf_export_dir}", "Info", "INFO")

        return {'FINISHED'}


# Cleanup Collections operator

class CleanupCollection(bpy.types.Operator):
    """Cleans up the Collision Models collection, if it exists, by removing any empty subcollections"""
    bl_idname = "object.src_eng_cleanup_collection"
    bl_label = "Cleanup Collection"
    bl_options = {'REGISTER'}

    def execute(self, context):

        if "Collision Models" in bpy.data.collections.keys():

            removed_count = 0

            children = [
                c.name for c in bpy.data.collections["Collision Models"].children_recursive]

            for c in children:
                if len(bpy.data.collections[c].objects) == 0:
                    removed_count += 1
                    bpy.data.collections.remove(bpy.data.collections[c])

            display_msg_box("Removed " + str(removed_count) +
                            " collection(s)", "Info", "INFO")
        else:
            display_msg_box(
                "There is no 'Collision Models' collection to clean up", "Info", "INFO")

        return {'FINISHED'}

class UnrealRename(bpy.types.Operator):
    bl_idname = "object.rename_collision_for_unreal"
    bl_label = "Rename Collision for Unreal"
    bl_description = "Renames _phys objects to UCX_ prefix for Unreal Engine compatibility"
    bl_options = {'REGISTER', 'UNDO'}

    def execute(self, context):
        phys_objects = [obj for obj in bpy.data.objects 
                       if obj.type == 'MESH' and "_phys" in obj.name]
        
        if not phys_objects:
            self.report({'INFO'}, "No collision meshes found")
            return {'CANCELLED'}
        
        renamed_count = 0
        
        for obj in phys_objects:

            new_name = obj.name.replace("_phys", "")
            
            if not new_name.startswith("UCX_"):
                new_name = "UCX_" + new_name
            
            if obj.name in bpy.data.collections.keys():
                bpy.data.collections[obj.name].name = new_name

            obj.name = new_name

            renamed_count += 1
        
       
        self.report({'INFO'}, f"Renamed {renamed_count} collision mesh(es) for Unreal Engine")
        return {'FINISHED'}


# End classes


ops = (
    GenerateFromFaces,
    GenerateFromUVMap,
    GenerateFromFracture,
    GenerateFromBisection,
    SplitUpSrcCollision,
    GenerateSourceQC,
    CopyQCOverrides,
    ClearQCOverrides,
    Cleanup_MergeAdjacentSimilars,
    Cleanup_RemoveThinHulls,
    Cleanup_MergeThinHulls,
    Cleanup_FindThinHulls,
    Cleanup_ForceConvex,
    Cleanup_RemoveInsideHulls,
    Cleanup_CountHulls,
    RecommendedCollSettings,
    CleanupCollection,
    UpdateVMF,
    ExportVMF,
    UnrealRename
)


def menu_func(self, context):
    for op in ops:
        self.layout.operator(op.bl_idname)

# MATERIALS PANEL


class MESH_PT_src_eng_coll_gen(bpy.types.Panel):
    bl_label = 'Source Engine Collision Tools'
    bl_idname = "MESH_PT_src_eng_coll_gen"
    bl_space_type = 'PROPERTIES'
    bl_region_type = 'WINDOW'
    bl_context = 'object'

    @ classmethod
    def poll(cls, context):
        return (context.object != None)

    def draw_header(self, context):
        layout = self.layout

    def draw(self, context):
        layout = self.layout


class MESH_PT_SrcEngCollGen_SubPanel_Generate(bpy.types.Panel):
    bl_parent_id = "MESH_PT_src_eng_coll_gen"
    bl_label = "Generate"
    bl_space_type = 'PROPERTIES'
    bl_region_type = 'WINDOW'
    bl_context = 'object'
    
    def draw(self, context):
        layout = self.layout
        rowGen = layout.row()
        row1 = layout.row()
        row2 = layout.row()
        row3 = layout.row()
        row4 = layout.row()
        row5 = layout.row()
        row6 = layout.row()
        layout.separator()

        rowFractGen = layout.row()
        rowSeparator1= layout.row()
        rowBisectGen = layout.row()

        rowGen.operator("object.src_eng_recc_settings")       
        row1.prop(bpy.context.scene.SrcEngCollProperties, "Decimate_Ratio")
        row2.prop(bpy.context.scene.SrcEngCollProperties, "Extrusion_Modifier")
        row3.prop(bpy.context.scene.SrcEngCollProperties, "Merge_Distance")
        row4.prop(bpy.context.scene.SrcEngCollProperties, "Dissolve")
        row4.prop(bpy.context.scene.SrcEngCollProperties, "Post_Merge")
        row5.operator("object.src_eng_gen_faces")
        row6.operator("object.src_eng_gen_uvmap")

        # Fracture Generator UI
        boxFractGen = rowFractGen.box()
        boxFractGen.label(text="Fracture")
        rowFractGen2 = boxFractGen.row()
        rowFractGen2.prop(bpy.context.scene.SrcEngCollProperties, "Fracture_Target")
        rowFractGen3 = boxFractGen.row()
        rowFractGen3.prop(bpy.context.scene.SrcEngCollProperties, "Voxel_Resolution")
        rowFractGen4 = boxFractGen.row()
        rowFractGen4.prop(bpy.context.scene.SrcEngCollProperties, "Fracture_Gap")
        rowFractGen5 = boxFractGen.row()
        rowFractGen5.operator("object.src_eng_gen_fracture")

        boxBisectGen = rowBisectGen.box()
        boxBisectGen.label(text="Bisection")
        rowBisectGen1 = boxBisectGen.row()
        rowBisectGen1.prop(bpy.context.scene.SrcEngCollProperties, "Bisections")
        rowBisectGen1.prop(bpy.context.scene.SrcEngCollProperties, "Bisect_Gap")
        rowBisectGen2 = boxBisectGen.row()
        rowBisectGen2.prop(bpy.context.scene.SrcEngCollProperties, "Bisect_Mode")
        rowBisectGen3 = boxBisectGen.row()
        rowBisectGen3.operator("object.src_eng_gen_bisect")

class MESH_PT_SrcEngCollGen_SubPanel_Cleanup(bpy.types.Panel):
    bl_parent_id = "MESH_PT_src_eng_coll_gen"
    bl_label = "Cleanup"
    bl_options = {"DEFAULT_CLOSED"}
    bl_space_type = 'PROPERTIES'
    bl_region_type = 'WINDOW'
    bl_context = 'object'
    
    def draw(self, context):
        layout = self.layout

        # Cleanup UI
        rowCleanup = layout.row()
        boxCleanup = rowCleanup.box()
        rowCleanup1_Label = boxCleanup.row()
        rowCleanup1 = boxCleanup.row()
        rowCleanup2 = boxCleanup.row()
        rowCleanup3_Label = boxCleanup.row()
        rowCleanup3 = boxCleanup.row()
        rowCleanup4 = boxCleanup.row()
        rowCleanup5 = boxCleanup.row()
        rowCleanup6 = boxCleanup.row()
        rowCleanup7_Label = boxCleanup.row()
        rowCleanup7 = boxCleanup.row()
        rowCleanup8 = boxCleanup.row()
        rowCleanup9 = boxCleanup.row()
        rowCleanup10 = boxCleanup.row()
        rowCleanup11_Label = boxCleanup.row()
        rowCleanup11 = boxCleanup.row()
        rowCleanup12 = boxCleanup.row()

        rowCleanup1_Label.label(text="Similarity")
        rowCleanup1.prop(
            bpy.context.scene.SrcEngCollProperties, "Similar_Factor")
        rowCleanup2.operator("object.src_eng_cleanup_merge_similars")

        rowCleanup3_Label.label(text="Thinness")
        rowCleanup3.prop(
            bpy.context.scene.SrcEngCollProperties, "Thin_Threshold")
        rowCleanup4.operator("object.src_eng_cleanup_remove_thin_hulls")
        rowCleanup5.operator("object.src_eng_cleanup_merge_thin_hulls")
        rowCleanup6.operator("object.src_eng_cleanup_find_thin_hulls")

        rowCleanup7_Label.label(text="Other")
        rowCleanup7.operator("object.src_eng_cleanup_force_convex")
        rowCleanup8.operator("object.src_eng_cleanup_remove_inside")
        rowCleanup9.operator("object.src_eng_cleanup_count_hulls")
        rowCleanup10.operator("object.src_eng_cleanup_collection")
        
        rowCleanup11_Label.label(text="Splitting")
        rowCleanup11.prop(
            bpy.context.scene.SrcEngCollProperties, "Split_Increment")
        rowCleanup12.operator("object.src_eng_split")

class MESH_PT_SrcEngCollGen_SubPanel_Compile(bpy.types.Panel):
    bl_parent_id = "MESH_PT_src_eng_coll_gen"
    bl_label = "Compile"
    bl_options = {"DEFAULT_CLOSED"}
    bl_space_type = 'PROPERTIES'
    bl_region_type = 'WINDOW'
    bl_context = 'object'
    
    def draw(self, context):
        layout = self.layout

        rowQC = layout.row()

        # Compile / QC UI
        boxQC = rowQC.box()
        boxQC.label(text="Compile Tools")
        rowQC1 = boxQC.row()
        rowQC2 = boxQC.row()
        rowQC3 = boxQC.row()
        rowQC4 = boxQC.row()
        rowQC5 = boxQC.row()
        rowQC6 = boxQC.row()
        rowQC7 = boxQC.row()
        rowQC8 = boxQC.row()
        rowQC9 = boxQC.row()

        rowQC1.prop(bpy.context.scene.SrcEngCollProperties, "QC_Folder")
        rowQC2.prop(bpy.context.scene.SrcEngCollProperties,
                    "QC_Src_Models_Dir")
        rowQC3.prop(bpy.context.scene.SrcEngCollProperties, "QC_Src_Mats_Dir")
        rowQC4.enabled = len(bpy.context.scene.SrcEngCollProperties.QC_Folder) > 0 and len(
            bpy.context.scene.SrcEngCollProperties.QC_Src_Models_Dir) > 0 and len(bpy.context.scene.SrcEngCollProperties.QC_Src_Mats_Dir) > 0
        rowQC4.prop(bpy.context.scene.SrcEngCollProperties, "QC_SurfaceProp")
        rowQC5.operator("object.src_eng_qc")
        rowQC6.operator("object.copy_qc_overrides")
        rowQC7.operator("object.clear_qc_overrides")
        rowQC8.prop(bpy.context.scene.SrcEngCollProperties, "VMF_File")
        rowQC9.prop(bpy.context.scene.SrcEngCollProperties, "VMF_Remove")
        rowQC9.operator("object.src_eng_vmf_update")
        rowQC9.enabled = len(
            bpy.context.scene.SrcEngCollProperties.VMF_File) > 0
        
        # Export as Brushes
        boxVMF = layout.box()
        boxVMF.label(text="Hammer Brushes")
        rowVMF1 = boxVMF.row()
        rowVMF2 = boxVMF.row()
        rowVMF3 = boxVMF.row()

        rowVMF1.prop(bpy.context.scene.SrcEngCollProperties, "VMF_Export_Dir")
        rowVMF2.prop(bpy.context.scene.SrcEngCollProperties, "VMF_Texture")
        rowVMF3.operator("object.src_eng_vmf_export")
        
# End of classes


classes = (
    MESH_PT_src_eng_coll_gen,
    MESH_PT_SrcEngCollGen_SubPanel_Generate,
    MESH_PT_SrcEngCollGen_SubPanel_Cleanup,
    MESH_PT_SrcEngCollGen_SubPanel_Compile,
    SrcEngCollProperties,
    GenerateFromFaces,
    GenerateFromUVMap,
    GenerateFromFracture,
    GenerateFromBisection,
    SplitUpSrcCollision,
    GenerateSourceQC,
    CopyQCOverrides,
    ClearQCOverrides,
    Cleanup_MergeAdjacentSimilars,
    Cleanup_RemoveThinHulls,
    Cleanup_MergeThinHulls,
    Cleanup_FindThinHulls,
    Cleanup_ForceConvex,
    Cleanup_RemoveInsideHulls,
    Cleanup_CountHulls,
    CleanupCollection,
    RecommendedCollSettings,
    UpdateVMF,
    ExportVMF,
    UnrealRename
)


def register():
    for cls in classes:
        bpy.utils.register_class(cls)

    bpy.types.Scene.SrcEngCollProperties = bpy.props.PointerProperty(
        type=SrcEngCollProperties)


def unregister():
    for cls in classes:
        bpy.utils.unregister_class(cls)

    del bpy.types.Scene.SrcEngCollProperties


if __name__ == "__main__":
    register()
